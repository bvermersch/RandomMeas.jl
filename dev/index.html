<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · RandomMeas.jl</title><meta name="title" content="Home · RandomMeas.jl"/><meta property="og:title" content="Home · RandomMeas.jl"/><meta property="twitter:title" content="Home · RandomMeas.jl"/><meta name="description" content="Documentation for RandomMeas.jl."/><meta property="og:description" content="Documentation for RandomMeas.jl."/><meta property="twitter:description" content="Documentation for RandomMeas.jl."/><meta property="og:url" content="https://bvermersch.github.io/RandomMeas.jl/"/><meta property="twitter:url" content="https://bvermersch.github.io/RandomMeas.jl/"/><link rel="canonical" href="https://bvermersch.github.io/RandomMeas.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="RandomMeas.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>RandomMeas.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Data-acquisition"><span>Data acquisition</span></a></li><li><a class="tocitem" href="#Postprocessing-(excluding-classical-shadows)"><span>Postprocessing (excluding classical shadows)</span></a></li><li><a class="tocitem" href="#Postprocessing-for-classical-shadows"><span>Postprocessing for classical shadows</span></a></li><li><a class="tocitem" href="#Simulating-quantum-circuits"><span>Simulating quantum circuits</span></a></li><li><a class="tocitem" href="#Additional-useful-routines-for-ITensor"><span>Additional useful routines for ITensor</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bvermersch/RandomMeas.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bvermersch/RandomMeas.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="RandomMeas"><a class="docs-heading-anchor" href="#RandomMeas">RandomMeas</a><a id="RandomMeas-1"></a><a class="docs-heading-anchor-permalink" href="#RandomMeas" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/bvermersch/RandomMeas.jl">RandomMeas.jl</a>: The randomized measurement toolbox in Julia</p><ul><li><a href="#Data-acquisition">Data acquisition</a></li><li class="no-marker"><ul><li><a href="#Data-acquisition-types">Data acquisition types</a></li><li><a href="#Data-acquisition-routines">Data acquisition routines</a></li></ul></li><li><a href="#Postprocessing-(excluding-classical-shadows)">Postprocessing (excluding classical shadows)</a></li><li><a href="#Postprocessing-for-classical-shadows">Postprocessing for classical shadows</a></li><li class="no-marker"><ul><li><a href="#Classical-shadow-types">Classical shadow types</a></li><li><a href="#Classical-shadow-routines">Classical shadow routines</a></li></ul></li><li><a href="#Simulating-quantum-circuits">Simulating quantum circuits</a></li><li><a href="#Additional-useful-routines-for-ITensor">Additional useful routines for ITensor</a></li><li><a href="#Examples">Examples</a></li><li class="no-marker"><ul><li><a href="#Classical-shadows">Classical shadows</a></li><li><a href="#Quantum-benchmark">Quantum benchmark</a></li><li><a href="#Entanglement">Entanglement</a></li><li><a href="#Miscellanous">Miscellanous</a></li></ul></li></ul><h2 id="Data-acquisition"><a class="docs-heading-anchor" href="#Data-acquisition">Data acquisition</a><a id="Data-acquisition-1"></a><a class="docs-heading-anchor-permalink" href="#Data-acquisition" title="Permalink"></a></h2><h3 id="Data-acquisition-types"><a class="docs-heading-anchor" href="#Data-acquisition-types">Data acquisition types</a><a id="Data-acquisition-types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-acquisition-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.AbstractMeasurementSetting" href="#RandomMeas.AbstractMeasurementSetting"><code>RandomMeas.AbstractMeasurementSetting</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMeasurementSetting</code></pre><p>An abstract type representing a general measurement setting. Concrete implementations (e.g. <code>LocalUnitaryMeasurementSetting</code>, <code>ComputationalBasisMeasurementSetting</code>) should subtype this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementStructures.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.ComputationalBasisMeasurementSetting" href="#RandomMeas.ComputationalBasisMeasurementSetting"><code>RandomMeas.ComputationalBasisMeasurementSetting</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComputationalBasisMeasurementSetting</code></pre><p>A struct representing computational basis measurement settings for quantum systems. This setting uses the computational basis, so that each local unitary is by construction simply the identity operator.</p><p><strong>Fields</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>local_unitary::Vector{ITensor}</code>: A vector of N identity ITensors.</li><li><code>site_indices::Vector{Index{Int64}}</code>: A vector of site indices (length N).</li></ul><p><strong>Constraints</strong></p><ul><li><code>N == length(site_indices)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementStructures.jl#L69-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.LocalMeasurementSetting" href="#RandomMeas.LocalMeasurementSetting"><code>RandomMeas.LocalMeasurementSetting</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalMeasurementSetting</code></pre><p>An abstract type for measurement settings that correspond to local (i.e. single qubit/site) measurements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementStructures.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.LocalUnitaryMeasurementSetting" href="#RandomMeas.LocalUnitaryMeasurementSetting"><code>RandomMeas.LocalUnitaryMeasurementSetting</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalUnitaryMeasurementSetting(N, local_unitary, site_indices)</code></pre><p>A measurement setting where each qubit is specified by a single-qubit rotation. Rotates from the computational basis into the measurement basis.</p><p><strong>Fields</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>local_unitary::Vector{ITensor}</code>: A vector of <code>N</code> ITensors representing the local unitary basis rotations.</li><li><code>site_indices::Vector{Index{Int64}}</code>: A vector of site indices of length <code>N</code>.</li></ul><p><strong>Constraints</strong></p><ul><li><code>N == length(local_unitary) == length(site_indices)</code>.</li><li>Each ITensor in <code>local_unitary</code> has exactly <strong>two indices</strong>:<ul><li>One unprimed (<code>site_indices[i]</code>)</li><li>One primed (<code>prime(site_indices[i])</code>).</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementStructures.jl#L26-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementData" href="#RandomMeas.MeasurementData"><code>RandomMeas.MeasurementData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementData{T}</code></pre><p>A container for measurement data and settings obtained in actual or simulated quantum experiments.</p><p><strong>Fields</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>NM::Int</code>: Number of measurements per setting.</li><li><code>measurement_results::Array{Int, 2}</code>: A 2D array of binary measurement results with dimensions <code>(NM, N)</code>.</li><li><code>measurement_setting::T</code>: A measurement setting of type <code>T</code> (subtype of <code>AbstractMeasurementSetting</code>) or <code>nothing</code>.</li></ul><p><strong>Type Parameter</strong></p><ul><li><code>T</code>: The type of the measurement setting, constrained to <code>Union{Nothing, AbstractMeasurementSetting}</code>.</li></ul><p><strong>Usage</strong></p><p>Typically constructed via the provided constructors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementStructures.jl#L136-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementGroup" href="#RandomMeas.MeasurementGroup"><code>RandomMeas.MeasurementGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementGroup{T}</code></pre><p>A container for a group of measurement data objects used in actual or simulated quantum experiments.</p><p><strong>Fields</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>NU::Int</code>: Number of measurement data objects.</li><li><code>NM::Int</code>: Number of measurements per setting.</li><li><code>measurements::Vector{MeasurementData{T}}</code>: A vector of measurement data objects.</li></ul><p><strong>Type Parameter</strong></p><ul><li><code>T</code>: The type of the measurement setting for each measurement data object, constrained to <code>Union{Nothing, AbstractMeasurementSetting}</code>.</li></ul><p><strong>Usage</strong></p><p>Typically constructed via one of the provided constructors.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Assume setting1 and setting2 are valid measurement settings
data1 = MeasurementData(results1; measurement_setting=setting1)
data2 = MeasurementData(results2; measurement_setting=setting2)
group = MeasurementGroup([data1, data2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementStructures.jl#L221-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementProbability" href="#RandomMeas.MeasurementProbability"><code>RandomMeas.MeasurementProbability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementProbability{T}

A container for measurement probabilities and settings obtained either estimated from measurement data or directly computed from quantum states.</code></pre><p><strong>Fields</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>measurement_probability::ITensor</code>: An ITensor representing Born probability.</li><li><code>measurement_setting::T</code>: A measurement setting of type <code>T</code> or <code>nothing</code>.</li><li><code>site_indices::Vector{Index{Int64}}</code>: A vector of site indices (length N).</li></ul><p><strong>Type Parameter</strong></p><ul><li><code>T</code>: The type of measurement setting, constrained to <code>Union{Nothing, AbstractMeasurementSetting}</code>.</li></ul><p><strong>Usage</strong></p><p>Constructed either from measurement data or directly from quantum states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementStructures.jl#L180-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.ShallowUnitaryMeasurementSetting" href="#RandomMeas.ShallowUnitaryMeasurementSetting"><code>RandomMeas.ShallowUnitaryMeasurementSetting</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShallowUnitaryMeasurementSetting</code></pre><p>A struct representing measurement settings which is, for each qubit, specified through a single qubit rotation, rotating from the computational basis into the measurement basis.</p><p><strong>Fields</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li>&#39;K::Int`: Number of gates that creates the shallow_unitary</li><li><code>localunitary::Vector{ITensor}</code>: A vector of Ngates representing the shallow unitary</li><li><code>site_indices::Vector{Index{Int64}}</code>: A vector of site indices of length N.</li></ul><p><strong>Constructor</strong></p><p>Creates a <code>ShallowUnitaryMeasurementSetting</code> object after validating that:</p><ul><li>The length of <code>local_unitary</code> equals <code>K</code></li><li>The length of <code>site_indices</code> equals <code>N</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementStructures.jl#L100-L115">source</a></section></article><h3 id="Data-acquisition-routines"><a class="docs-heading-anchor" href="#Data-acquisition-routines">Data acquisition routines</a><a id="Data-acquisition-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Data-acquisition-routines" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.ComputationalBasisMeasurementSetting-Tuple{Int64}" href="#RandomMeas.ComputationalBasisMeasurementSetting-Tuple{Int64}"><code>RandomMeas.ComputationalBasisMeasurementSetting</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComputationalBasisMeasurementSetting(N; site_indices=nothing)</code></pre><p>Create a <code>ComputationalBasisMeasurementSetting</code> for <code>N</code> sites. This setting corresponds to measurement in the computational basis.</p><p><strong>Arguments:</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>site_indices::Union{Vector{Index{Int64}}, Nothing}</code> (optional): Site indices. If <code>nothing</code>, they are automatically generated.</li></ul><p><strong>Returns:</strong></p><ul><li>A <code>ComputationalBasisMeasurementSetting</code> object.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">setting = ComputationalBasisMeasurementSetting(4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementSetting.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.LocalUnitaryMeasurementSetting-Tuple{Array{ComplexF64, 3}}" href="#RandomMeas.LocalUnitaryMeasurementSetting-Tuple{Array{ComplexF64, 3}}"><code>RandomMeas.LocalUnitaryMeasurementSetting</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalUnitaryMeasurementSetting(local_unitary_array; site_indices=nothing)</code></pre><p>Create a <code>LocalUnitaryMeasurementSetting</code> object from an <code>N × 2 × 2</code> array of unitary matrices.</p><p><strong>Arguments:</strong></p><ul><li><code>local_unitary_array::Array{ComplexF64, 3}</code>: An <code>N × 2 × 2</code> array of unitary matrices.</li><li><code>site_indices::Union{Vector{Index{Int64}}, Nothing}</code> (optional): Site indices. If <code>nothing</code>, they are automatically generated.</li></ul><p><strong>Returns:</strong></p><ul><li>A <code>LocalUnitaryMeasurementSetting</code> object.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">unitary_array = rand(ComplexF64, 4, 2, 2)
setting = LocalUnitaryMeasurementSetting(unitary_array)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementSetting.jl#L28-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.LocalUnitaryMeasurementSetting-Tuple{Int64}" href="#RandomMeas.LocalUnitaryMeasurementSetting-Tuple{Int64}"><code>RandomMeas.LocalUnitaryMeasurementSetting</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalUnitaryMeasurementSetting(N; site_indices=nothing, ensemble=&quot;Haar&quot;)</code></pre><p>Create a <code>LocalUnitaryMeasurementSetting</code> object by randomly sampling local unitary operators.</p><p><strong>Arguments:</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>site_indices::Union{Vector{Index}, Nothing}</code> (optional): Site indices. If <code>nothing</code>, they are automatically generated.</li><li><code>ensemble::String</code>: Type of random unitary (<code>&quot;Haar&quot;</code>, <code>&quot;Pauli&quot;</code>, <code>&quot;Identity&quot;</code>).</li></ul><p><strong>Returns:</strong></p><ul><li>A <code>LocalUnitaryMeasurementSetting</code> object.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">setting = LocalUnitaryMeasurementSetting(4, ensemble=&quot;Haar&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementSetting.jl#L61-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.ShallowUnitaryMeasurementSetting-Tuple{Int64, Int64}" href="#RandomMeas.ShallowUnitaryMeasurementSetting-Tuple{Int64, Int64}"><code>RandomMeas.ShallowUnitaryMeasurementSetting</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShallowUnitaryMeasurementSetting(N, depth; site_indices=nothing)</code></pre><p>Create a <code>ShallowUnitaryMeasurementSetting</code> object by generating a random quantum circuit.</p><p><strong>Arguments:</strong></p><ul><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>depth::Int</code>: Depth of the random circuit.</li><li><code>site_indices::Union{Vector{Index{Int64}}, Nothing}</code> (optional): Site indices. If <code>nothing</code>, they are automatically generated.</li></ul><p><strong>Returns:</strong></p><ul><li>A <code>ShallowUnitaryMeasurementSetting</code> object.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">setting = ShallowUnitaryMeasurementSetting(4, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementSetting.jl#L94-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.export_LocalUnitaryMeasurementSetting-Tuple{LocalUnitaryMeasurementSetting, String}" href="#RandomMeas.export_LocalUnitaryMeasurementSetting-Tuple{LocalUnitaryMeasurementSetting, String}"><code>RandomMeas.export_LocalUnitaryMeasurementSetting</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Export the unitary in a LocalUnitaryMeasurementSetting object to an .npz file with a single field: local_unitary.</p><p><strong>Arguments:</strong></p><ul><li><code>ms::LocalUnitaryMeasurementSetting</code>: The measurement settings to export.</li><li><code>filepath::String</code>: Path to the output .npz file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementSetting.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_rotation" href="#RandomMeas.get_rotation"><code>RandomMeas.get_rotation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_rotation(site_index, ensemble=&quot;Haar&quot;)</code></pre><p>Generate a single-qubit unitary sampled from a specified ensemble.</p><p><strong>Arguments:</strong></p><ul><li><code>site_index::Index{Int64}</code>: Site index.</li><li><code>ensemble::String</code>: Type of unitary ensemble (<code>&quot;Haar&quot;</code>, <code>&quot;Pauli&quot;</code>, <code>&quot;Identity&quot;</code>).</li></ul><p><strong>Returns:</strong></p><ul><li>An <code>ITensor</code> representing the unitary transformation.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">U = get_rotation(site_index, &quot;Pauli&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementSetting.jl#L127-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.import_LocalUnitaryMeasurementSetting-Tuple{String}" href="#RandomMeas.import_LocalUnitaryMeasurementSetting-Tuple{String}"><code>RandomMeas.import_LocalUnitaryMeasurementSetting</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Import unitary from an .npz file and create a LocalUnitaryMeasurementSetting object.</p><p><strong>Arguments:</strong></p><ul><li><code>filepath::String</code>: Path to the input .npz file.</li><li><code>site_indices::Union{Vector{Index{Int64}}, Nothing}</code>: Optional site indices. If not provided, they will be generated.</li></ul><p><strong>Returns:</strong></p><ul><li>A LocalUnitaryMeasurementSettings object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementSetting.jl#L231-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.reduce_to_subsystem-Tuple{LocalMeasurementSetting, Vector{Int64}}" href="#RandomMeas.reduce_to_subsystem-Tuple{LocalMeasurementSetting, Vector{Int64}}"><code>RandomMeas.reduce_to_subsystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_to_subsystem(settings, subsystem)</code></pre><p>Reduce a <code>LocalMeasurementSetting</code> object to a specified subsystem.</p><p><strong>Arguments:</strong></p><ul><li><code>settings::LocalMeasurementSetting</code>: The original measurement settings object.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem to retain.</li></ul><p><strong>Returns:</strong></p><ul><li>A new <code>LocalMeasurementSetting</code> object corresponding to the specified subsystem.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">reduced_setting = reduce_to_subsystem(full_setting, [1, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementSetting.jl#L175-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementData-Tuple{Union{MPO, MPS}, Int64, Union{ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting, ShallowUnitaryMeasurementSetting}}" href="#RandomMeas.MeasurementData-Tuple{Union{MPO, MPS}, Int64, Union{ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting, ShallowUnitaryMeasurementSetting}}"><code>RandomMeas.MeasurementData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementData(ψ::Union{MPO, MPS}, NM::Int; mode::String = &quot;MPS/MPO&quot;, measurement_setting::Union{LocalUnitaryMeasurementSetting, ComputationalBasisMeasurementSetting, ShallowUnitaryMeasurementSetting} = nothing)</code></pre><p>Returns a <code>MeasurementData</code> object by sampling <code>NM</code> projective measurements from the quantum state <code>ψ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::Union{MPO, MPS}</code>: The quantum state represented as a Matrix Product Operator (MPO) or Matrix Product State (MPS).</li><li><code>NM::Int</code>: The number of measurement shots to simulate for each setting.</li><li><code>mode::String</code> (optional): Specifies the simulation method. Options:<ul><li><code>&quot;dense&quot;</code>: Uses the dense representation.</li><li><code>&quot;MPS/MPO&quot;</code> (default): Uses tensor network methods for memory efficiency.</li></ul></li><li><code>measurement_setting</code> (optional): A measurement setting object (if not provided, defaults to computational basis measurements).</li></ul><p><strong>Returns</strong></p><p>A <code>MeasurementData</code> object with the corresponding measurement results and setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementData.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementData-Union{Tuple{Matrix{Int64}}, Tuple{T}} where T&lt;:Union{Nothing, RandomMeas.AbstractMeasurementSetting}" href="#RandomMeas.MeasurementData-Union{Tuple{Matrix{Int64}}, Tuple{T}} where T&lt;:Union{Nothing, RandomMeas.AbstractMeasurementSetting}"><code>RandomMeas.MeasurementData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementData(measurement_results::Array{Int, 2}; measurement_setting::Union{T, Nothing} = nothing)</code></pre><p>Creates a <code>MeasurementData</code> object by inferring the dimensions of the measurement results and validating the provided setting.</p><p><strong>Arguments</strong></p><ul><li><code>measurement_results::Array{Int, 2}</code>: A 2D array of binary measurement results with shape <code>(NM, N)</code>.</li><li><code>measurement_setting::Union{T &lt;: AbstractMeasurementSetting, Nothing}</code> (optional): Measurement setting or <code>nothing</code> if not provided.</li></ul><p><strong>Returns</strong></p><p>A <code>MeasurementData</code> object with inferred dimensions and validated setting.</p><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If the dimensions of <code>measurement_results</code> and <code>measurement_setting</code> are inconsistent.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># With measurement setting
setting = LocalUnitaryMeasurementSetting(4, ensemble=&quot;Haar&quot;)
results = rand(1:2, 10, 4)
data_with_setting = MeasurementData(results; measurement_setting=setting)

# Without measurement setting
data_without_setting = MeasurementData(rand(1:2, 10, 4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementData.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementData-Union{Tuple{T}, Tuple{MeasurementProbability{T}, Int64}} where T&lt;:Union{Nothing, RandomMeas.AbstractMeasurementSetting}" href="#RandomMeas.MeasurementData-Union{Tuple{T}, Tuple{MeasurementProbability{T}, Int64}} where T&lt;:Union{Nothing, RandomMeas.AbstractMeasurementSetting}"><code>RandomMeas.MeasurementData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementData(measurement_probability::MeasurementProbability{T}, NM::Int) where T &lt;: Union{Nothing, AbstractMeasurementSetting}</code></pre><p>Returns a <code>MeasurementData</code> object by sampling <code>NM</code> projective measurements based on the provided measurement probability.</p><p><strong>Arguments</strong></p><ul><li><code>measurement_probability::MeasurementProbability</code>: A container with the measurement probability (an ITensor) and associated settings.</li><li><code>NM::Int</code>: The number of projective measurements to sample.</li></ul><p><strong>Returns</strong></p><p>A <code>MeasurementData</code> object with dimensions inferred from the measurement probability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementData.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.export_MeasurementData-Union{Tuple{T}, Tuple{MeasurementData{T}, String}} where T&lt;:Union{Nothing, ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting}" href="#RandomMeas.export_MeasurementData-Union{Tuple{T}, Tuple{MeasurementData{T}, String}} where T&lt;:Union{Nothing, ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting}"><code>RandomMeas.export_MeasurementData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">export_measurement_data(data::MeasurementData, filepath::String)</code></pre><p>Exports measurement data to a <code>.npz</code> file.</p><p><strong>Arguments</strong></p><ul><li><code>data::MeasurementData</code>: The measurement data object containing measurement results and optionally a LocalUnitaryMeasurementSetting setting.</li><li><code>filepath::String</code>: The file path where the data will be exported.</li></ul><p><strong>Details</strong></p><ul><li>The <code>measurement_results</code> are exported directly as they are.</li><li>If <code>measurement_setting</code> is provided, the associated <code>local_unitaries</code> are extracted, reshaped, and included in the export.</li></ul><p><strong>Notes</strong></p><ul><li>The exported <code>.npz</code> file will contain:<ul><li><code>&quot;measurement_results&quot;</code>: A 2D array of shape <code>(NM, N)</code>, where:<ul><li><code>NM</code>: Number of measurements per setting.</li><li><code>N</code>: Number of qubits/sites.</li></ul></li><li><code>&quot;local_unitaries&quot;</code> (optional): A 4D array of shape <code>(N, 2, 2)</code> representing the unitary transformations for each site.</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">
# Create MeasurementData object
data = MeasurementData(measurement_results; measurement_setting=measurement_setting)

# Export to a file
export_measurement_data(data, &quot;exported_data.npz&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementData.jl#L228-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.import_MeasurementData-Tuple{String}" href="#RandomMeas.import_MeasurementData-Tuple{String}"><code>RandomMeas.import_MeasurementData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_measurement_data(filepath::String; predefined_setting=nothing, site_indices=nothing)</code></pre><p>Imports measurement results and optional measurement settings from an archive file.</p><p><strong>Arguments</strong></p><ul><li><code>filepath::String</code>: Path to the <code>.npz</code> file containing the measurement results and optionally local unitaries. The file should contain at least a field <code>measurement_results</code> (2D binary array of shape <code>(NM, N)</code>), and optionally a field <code>local_unitaries</code> (local unitaries as a Nx2x2 array).</li><li><code>predefined_setting</code> (optional): A predefined <code>MeasurementSetting</code> object. If provided, this will be used instead of the file&#39;s setting.</li><li><code>site_indices</code> (optional): A vector of site indices to be used when constructing <code>LocalUnitaryMeasurementSetting</code> from the field <code>local_unitaries</code> (only relevant if predefined_setting is not provided). If not provided, the default site indices will be generated internally.</li></ul><p><strong>Returns</strong></p><p>A <code>MeasurementData</code> object containing the imported results and settings.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Import with predefined settings
setting = LocalUnitaryMeasurementSetting(local_unitaries; site_indices=siteinds(&quot;Qubit&quot;, 5))
data_with_setting = import_measurement_data(&quot;data.npz&quot;; predefined_setting=setting)

# Import with site indices provided
data_with_indices = import_measurement_data(&quot;data.npz&quot;; site_indices=siteinds(&quot;Qubit&quot;, 5))

# Import without any additional options
data = import_measurement_data(&quot;data.npz&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementData.jl#L162-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.reduce_to_subsystem-Union{Tuple{T}, Tuple{MeasurementData{T}, Vector{Int64}}} where T&lt;:Union{Nothing, LocalMeasurementSetting}" href="#RandomMeas.reduce_to_subsystem-Union{Tuple{T}, Tuple{MeasurementData{T}, Vector{Int64}}} where T&lt;:Union{Nothing, LocalMeasurementSetting}"><code>RandomMeas.reduce_to_subsystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_to_subsystem(data::MeasurementData{T}, subsystem::Vector{Int}) where T &lt;: Union{Nothing, LocalMeasurementSetting}</code></pre><p>Reduce a <code>MeasurementData</code> object to a specified subsystem, preserving the measurement setting type if available.</p><p><strong>Arguments</strong></p><ul><li><code>data::MeasurementData{T}</code>: The original measurement data object, where <code>T</code> is either <code>nothing</code> or a subtype of <code>LocalMeasurementSetting</code>.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem to retain. Each index must be between 1 and <code>data.N</code>.</li></ul><p><strong>Returns</strong></p><p>A new <code>MeasurementData{T}</code> object with:</p><ul><li>The measurement results reduced from dimensions <code>(NM, N)</code> to <code>(NM, |subsystem|)</code>.</li><li>The measurement setting reduced accordingly (if one is provided), or remaining as <code>nothing</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Suppose `data` is a MeasurementData object with N = 4.
# To retain only sites 1 and 3:
reduced_data = reduce_to_subsystem(data, [1, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementData.jl#L123-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementGroup-Tuple{Union{MPO, MPS}, Int64, Int64, Int64}" href="#RandomMeas.MeasurementGroup-Tuple{Union{MPO, MPS}, Int64, Int64, Int64}"><code>RandomMeas.MeasurementGroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementGroup(ψ::Union{MPO, MPS}, NU::Int, NM::Int, depth::Int; mode::String = “MPS/MPO”, progress_bar::Bool=false)</code></pre><p>::MeasurementGroup{ShallowUnitaryMeasurementSetting}</p><p>Construct a MeasurementGroup from a quantum state <code>ψ</code> by generating <code>NU</code> shallow measurement settings and simulating <code>NM</code> measurements per unitary.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::Union{MPO, MPS}</code>: The quantum state.</li><li><code>NU::Int</code>: Number of measurement data objects to generate.</li><li><code>NM::Int</code>: Number of measurements per setting.</li><li><code>depth::Int</code>: Circuit depth for shallow settings.</li><li><code>mode::String</code>: Simulation mode; defaults to “MPS/MPO”.</li><li><code>progress_bar</code>::Bool: Whether to show a progress bar.</li></ul><p><strong>Returns</strong></p><p>A MeasurementGroup{ShallowUnitaryMeasurementSetting} object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementGroup.jl#L86-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementGroup-Tuple{Union{MPO, MPS}, Int64, Int64}" href="#RandomMeas.MeasurementGroup-Tuple{Union{MPO, MPS}, Int64, Int64}"><code>RandomMeas.MeasurementGroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementGroup(ψ::Union{MPO, MPS}, NU::Int, NM::Int; mode::String = “MPS/MPO”, progress_bar::Bool=false)</code></pre><p>::MeasurementGroup{LocalUnitaryMeasurementSetting}</p><p>Construct a MeasurementGroup from a quantum state <code>ψ</code> by generating <code>NU</code> local measurement settings and simulating <code>NM</code> projective measurements per setting.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::Union{MPO, MPS}</code>: The quantum state.</li><li><code>NU::Int</code>: Number of measurement data objects to generate.</li><li><code>NM::Int</code>: Number of measurements per setting.</li><li><code>mode::String</code>: Simulation mode; defaults to “MPS/MPO”.</li><li><code>progress_bar::Bool</code>: Whether to show a progress bar.</li></ul><p><strong>Returns</strong></p><p>A MeasurementGroup{LocalUnitaryMeasurementSetting} object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementGroup.jl#L43-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.MeasurementGroup-Union{Tuple{Array{MeasurementData{T}, 1}}, Tuple{T}} where T&lt;:Union{Nothing, RandomMeas.AbstractMeasurementSetting}" href="#RandomMeas.MeasurementGroup-Union{Tuple{Array{MeasurementData{T}, 1}}, Tuple{T}} where T&lt;:Union{Nothing, RandomMeas.AbstractMeasurementSetting}"><code>RandomMeas.MeasurementGroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementGroup(measurements::Vector{MeasurementData{T}}) where {T &lt;: Union{Nothing, AbstractMeasurementSetting}}</code></pre><p>Construct a <code>MeasurementGroup</code> object by inferring dimensions from a vector of <code>MeasurementData</code> objects.</p><p><strong>Arguments</strong></p><ul><li><code>measurements::Vector{MeasurementData{T}}</code>: A vector of <code>MeasurementData</code> objects.</li></ul><p><strong>Returns</strong></p><p>A <code>MeasurementGroup</code> object with:</p><ul><li><code>N</code>: Inferred from the first element (assumed consistent across all elements).</li><li><code>NU</code>: Number of measurement data objects.</li><li><code>NM</code>: Inferred from the first element.</li><li><code>measurements</code>: The provided vector.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">setting1 = LocalUnitaryMeasurementSetting(4, ensemble=&quot;Haar&quot;)
results1 = rand(1:2, 10, 4)
data1 = MeasurementData(results1; measurement_setting=setting1)
setting2 = LocalUnitaryMeasurementSetting(4, ensemble=&quot;Haar&quot;)
results2 = rand(1:2, 10, 4)
data2 = MeasurementData(results2; measurement_setting=setting2)
group = MeasurementGroup([data1, data2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementGroup.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.export_MeasurementGroup-Union{Tuple{T}, Tuple{MeasurementGroup{T}, String}} where T&lt;:Union{Nothing, ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting}" href="#RandomMeas.export_MeasurementGroup-Union{Tuple{T}, Tuple{MeasurementGroup{T}, String}} where T&lt;:Union{Nothing, ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting}"><code>RandomMeas.export_MeasurementGroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">export_MeasurementGroup(group::MeasurementGroup{T}, filepath::String)</code></pre><p>Export a MeasurementGroup object to an NPZ file.</p><p><strong>Arguments</strong></p><ul><li><code>group::MeasurementGroup{T}</code>: A MeasurementGroup object where each MeasurementData may have its own measurement setting of type T (with T &lt;: Union{Nothing, LocalUnitaryMeasurementSetting, ComputationalBasisMeasurementSetting}).</li><li><code>filepath::String</code>: The file path where the NPZ file will be written.</li></ul><p><strong>Details</strong></p><ul><li>The measurement results from each MeasurementData object (each of shape (NM, N)) are stacked into a 3D array of shape (NU, NM, N), where NU is the number of MeasurementData objects.</li><li>The measurement settings are exported as a Complex array of size NU x N x 2 x 2 if present.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementGroup.jl#L162-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.import_MeasurementGroup-Tuple{String}" href="#RandomMeas.import_MeasurementGroup-Tuple{String}"><code>RandomMeas.import_MeasurementGroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_MeasurementGroup(filepath::String; predefined_settings=nothing, site_indices=nothing) -&gt; MeasurementGroup</code></pre><p>Import a MeasurementGroup object from an NPZ file.</p><p><strong>Arguments</strong></p><ul><li><code>filepath::String</code>: The path to the NPZ file containing the exported MeasurementGroup data.</li><li><code>predefined_settings</code> (optional): A vector of predefined measurement settings (one per MeasurementData object). If provided, its length must equal the exported NU.</li><li><code>site_indices</code> (optional): A vector of N site indices to use when reconstructing the measurement setting. If not provided, default site indices are generated using <code>siteinds(&quot;Qubit&quot;, N)</code>.</li></ul><p><strong>Returns</strong></p><p>A MeasurementGroup object with:</p><ul><li>Measurement results reconstructed from a 3D array of shape (NU, NM, N).</li><li>A measurement setting for each MeasurementData object reconstructed from a 4D array of shape (NU, N, 2, 2) if present, or taken from <code>predefined_settings</code> if provided.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementGroup.jl#L211-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.reduce_to_subsystem-Union{Tuple{T}, Tuple{MeasurementGroup{T}, Vector{Int64}}} where T&lt;:Union{Nothing, LocalMeasurementSetting}" href="#RandomMeas.reduce_to_subsystem-Union{Tuple{T}, Tuple{MeasurementGroup{T}, Vector{Int64}}} where T&lt;:Union{Nothing, LocalMeasurementSetting}"><code>RandomMeas.reduce_to_subsystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_to_subsystem(
group::MeasurementGroup{T},
subsystem::Vector{Int}</code></pre><p>)::MeasurementGroup{T} where T &lt;: LocalMeasurementSetting</p><p>Reduce a <code>MeasurementGroup object (with</code>LocalUnitaryMeasurementSetting`) to a specified subsystem.</p><p><strong>Arguments</strong></p><ul><li><code>group::MeasurementGroup{LocalUnitaryMeasurementSetting}</code>: The original measurement data object.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem to retain.</li></ul><p><strong>Returns</strong></p><p>A new <code>MeasurementGroup</code> object corresponding to the specified subsystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/MeasurementGroup.jl#L131-L145">source</a></section></article><h2 id="Postprocessing-(excluding-classical-shadows)"><a class="docs-heading-anchor" href="#Postprocessing-(excluding-classical-shadows)">Postprocessing (excluding classical shadows)</a><a id="Postprocessing-(excluding-classical-shadows)-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing-(excluding-classical-shadows)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_XEB-Tuple{MPS, MeasurementData}" href="#RandomMeas.get_XEB-Tuple{MPS, MeasurementData}"><code>RandomMeas.get_XEB</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_XEB(ψ::MPS, measurement_data::MeasurementData)</code></pre><p>Return the linear cross-entropy for the measurement results in <code>measurement_data</code>, with respect to a theory state <code>ψ</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>ψ::MPS</code>: The theoretical state to compare against.</li><li><code>measurement_data::MeasurementData</code>: The measurement data object containing results and settings.</li></ul><p><strong>Returns:</strong></p><p>The linear cross-entropy as a <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Estimators.jl#L224-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_fidelity" href="#RandomMeas.get_fidelity"><code>RandomMeas.get_fidelity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_fidelity(
    group_1::MeasurementGroup,
    group_2::MeasurementGroup,
    subsystem::Vector{Int} = collect(1:group_1.N)
)</code></pre><p>Compute the fidelity of two quantum states Tr(ρ1 ρ2)/SROOT(Tr(ρ1^2),Tr(ρ2^2)) from measurement data by averaging the overlap of measurement results.</p><p><strong>Arguments</strong></p><ul><li><code>group_1::MeasurementGroup</code>: Measurement data for the first state.</li><li><code>group_2::MeasurementGroup</code>: Measurement data for the second state.</li><li><code>subsystem::Vector{Int}</code> (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.</li></ul><p><strong>Returns</strong></p><ul><li>The computed fidelity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Estimators.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_h_tensor" href="#RandomMeas.get_h_tensor"><code>RandomMeas.get_h_tensor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_h_tensor(s::Index, s_prime::Index) -&gt; ITensor</code></pre><p>Construct the Hamming tensor for given indices.</p><p><strong>Arguments</strong></p><ul><li><code>s::Index</code>: Unprimed site index.</li><li><code>s_prime::Index</code>: Primed site index.</li></ul><p><strong>Returns</strong></p><ul><li><code>Hamming_tensor::ITensor</code>: The Hamming tensor connecting <code>s</code> and <code>s_prime</code>.</li></ul><p><strong>Method</strong></p><ul><li>Initializes an <code>ITensor</code> with indices <code>s</code> and <code>s_prime</code>.</li><li>Assigns values to represent the Hamming distance operation:<ul><li>Diagonal elements are set to <code>1.0</code>.</li><li>Off-diagonal elements are set to <code>-0.5</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Estimators.jl#L185-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_overlap" href="#RandomMeas.get_overlap"><code>RandomMeas.get_overlap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_overlap(
    group_1::MeasurementGroup,
    group_2::MeasurementGroup,
    subsystem::Vector{Int} = collect(1:group_1.N);
    apply_bias_correction::Bool = false
)</code></pre><p>Compute the overlap of two quantum states from measurement data by averaging the overlap of measurement results.</p><p><strong>Arguments</strong></p><ul><li><code>group_1::MeasurementGroup</code>: Measurement data for the first state.</li><li><code>group_2::MeasurementGroup</code>: Measurement data for the second state.</li><li><code>subsystem::Vector{Int}</code> (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.</li><li><code>apply_bias_correction::Bool</code> (optional): Whether to apply bias correction for the overlap. Defaults to <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The computed overlap (or purity if <code>group_1 == group_2</code> and bias correction is applied).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Estimators.jl#L50-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_overlap-Tuple{MeasurementData, MeasurementData}" href="#RandomMeas.get_overlap-Tuple{MeasurementData, MeasurementData}"><code>RandomMeas.get_overlap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_overlap(
    data_1::MeasurementData,
    data_2::MeasurementData
)</code></pre><p>Compute the overlap between two quantum states for a single measurement setting.</p><p><strong>Arguments</strong></p><ul><li><code>data_1::MeasurementData</code>: Measurement Data for the first state, with dimensions <code>(NM, N)</code>.</li><li><code>data_2::MeasurementData</code>: Measurement Data for the second state, with dimensions <code>(NM, N)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The computed overlap for the single measurement setting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Estimators.jl#L96-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_overlap-Tuple{MeasurementProbability, MeasurementProbability}" href="#RandomMeas.get_overlap-Tuple{MeasurementProbability, MeasurementProbability}"><code>RandomMeas.get_overlap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_overlap(prob1::MeasurementProbability, prob2::MeasurementProbability) -&gt; Float64</code></pre><p>Compute the weighted overlap  <code>\2^N sum_s (-2)^{-D[s,s&#39;]}P(s)P(s&#39;)]</code> by sequentially applying the Hamming tensor to each qubit index and contracting with the second probability tensor.</p><p><strong>Arguments</strong></p><ul><li><code>prob1::MeasurementProbability</code>: The first Born probability tensor representing quantum state <code>rho1</code>.</li><li><code>prob2::MeasurementProbability</code>: The second Born probability tensor representing quantum state <code>rho2</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>weighted_overlap::Float64</code>: The computed trace <code>Tr(rho1 rho2)</code> scaled appropriately..</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ITensors

# Assume prob1 and prob2 are predefined MeasurementProbabilities
overlap = get_overlap(prob1, prob2)
println(&quot;Overlap: &quot;, overlap)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Estimators.jl#L137-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_purity" href="#RandomMeas.get_purity"><code>RandomMeas.get_purity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_purity(group::Measurementgroup, subsystem::Vector{Int} = collect(1:group.N))</code></pre><p>Compute the purity of a quantum state from measurement data by averaging the overlap of measurement results.</p><p><strong>Arguments</strong></p><ul><li><code>group::MeasurementGroup</code>: Measurement data containing the results and settings of randomized measurements.</li><li><code>subsystem::Vector{Int}</code> (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.</li></ul><p><strong>Returns</strong></p><ul><li>The computed purity for the specified subsystem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Estimators.jl#L34-L45">source</a></section></article><h2 id="Postprocessing-for-classical-shadows"><a class="docs-heading-anchor" href="#Postprocessing-for-classical-shadows">Postprocessing for classical shadows</a><a id="Postprocessing-for-classical-shadows-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing-for-classical-shadows" title="Permalink"></a></h2><h3 id="Classical-shadow-types"><a class="docs-heading-anchor" href="#Classical-shadow-types">Classical shadow types</a><a id="Classical-shadow-types-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-shadow-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.AbstractShadow" href="#RandomMeas.AbstractShadow"><code>RandomMeas.AbstractShadow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractShadow</code></pre><p>An abstract type representing a general classical shadow. Concrete subtypes should implement specific shadow methodologies, such as factorized or dense shadows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShadowStructures.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.DenseShadow" href="#RandomMeas.DenseShadow"><code>RandomMeas.DenseShadow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseShadow</code></pre><p>A struct representing a dense classical shadow (a 2^N x 2^N matrix), stored as a single ITensor with 2N indices.</p><p><strong>Fields</strong></p><ul><li><code>shadow_data::ITensor</code>: An ITensor with 2N indices representing the dense shadow.</li><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>site_indices::Vector{Index{Int64}}</code>: A vector of site indices (length N).</li></ul><p><strong>Constructor</strong></p><p><code>DenseShadow(shadow_data::ITensor, N::Int, site_indices::Vector{Index{Int64}})</code> validates that:</p><ul><li><code>site_indices</code> has length N.</li><li><code>shadow_data</code> has exactly 2N indices.</li><li>The set of unprimed indices in <code>shadow_data</code> matches <code>site_indices</code>.</li><li>The set of primed indices in <code>shadow_data</code> matches <code>map(prime, site_indices)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShadowStructures.jl#L60-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.FactorizedShadow" href="#RandomMeas.FactorizedShadow"><code>RandomMeas.FactorizedShadow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FactorizedShadow</code></pre><p>A struct representing a factorized classical shadow which can be represented as a tensor product of single qubit shadows.</p><p><strong>Fields</strong></p><ul><li><code>shadow_data::Vector{ITensor}</code>: A vector of ITensors (each 2×2) representing the shadow for each qubit/site.</li><li><code>N::Int</code>: Number of qubits/sites.</li><li><code>site_indices::Vector{Index{Int64}}</code>: A vector of site indices (length N).</li></ul><p><strong>Constructor</strong></p><p><code>FactorizedShadow(shadow_data::Vector{ITensor}, N::Int, site_indices::Vector{Index{Int64}})</code> validates that:</p><ul><li>The length of <code>shadow_data</code> and <code>site_indices</code> equals <code>N</code>.</li><li>Each ITensor in <code>shadow_data</code> has exactly two indices, which include the corresponding unprimed and primed site index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShadowStructures.jl#L21-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.ShallowShadow" href="#RandomMeas.ShallowShadow"><code>RandomMeas.ShallowShadow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShallowShadow</code></pre><p>A struct representing a shallow classical shadow, stored as a MPO ITensor object.</p><p><strong>Fields</strong></p><ul><li><code>shadow_data::MPOr</code>: An MPO representing the shallow shadow.</li><li><code>N::Int</code>: Number of sites (qubits).</li><li><code>site_indices::Vector{Index{Int64}}</code>: A vector of site indices (length N).</li></ul><p><strong>Constructor</strong></p><p><code>ShallowShadow(shadow_data::MPO, N::Int, site_indices::Vector{Index{Int64}})</code> validates that:</p><ul><li><code>site_indices</code> has length N.</li><li><code>shadow_data</code> has exactly N Tensors, and the site indices match with site_indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShadowStructures.jl#L102-L117">source</a></section></article><h3 id="Classical-shadow-routines"><a class="docs-heading-anchor" href="#Classical-shadow-routines">Classical shadow routines</a><a id="Classical-shadow-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-shadow-routines" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_expect_shadow-Tuple{MPO, AbstractArray{&lt;:AbstractShadow}}" href="#RandomMeas.get_expect_shadow-Tuple{MPO, AbstractArray{&lt;:AbstractShadow}}"><code>RandomMeas.get_expect_shadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_expect_shadow(O::MPO, shadows::AbstractArray{&lt;:AbstractShadow}; compute_sem::Bool = false)</code></pre><p>Compute the average expectation value of an MPO operator <code>O</code> using an array of shadow objects.</p><p><strong>Arguments</strong></p><ul><li><code>O::MPO</code>: The MPO operator whose expectation value is to be computed.</li><li><code>shadows::AbstractArray{&lt;:AbstractShadow}</code>: An array of shadow objects (of any shape) over which the expectation values are computed.</li><li><code>compute_sem::Bool</code> (optional): If <code>true</code>, also compute the standard error of the mean (SEM). Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>compute_sem</code> is <code>false</code>, returns the average expectation value.</li><li>If <code>compute_sem</code> is <code>true</code>, returns a tuple <code>(mean, sem)</code>, where <code>mean</code> is the average expectation value and <code>sem</code> is the standard error.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mean_val = get_expect_shadow(O, shadows)
mean_val, sem_val = get_expect_shadow(O, shadows; compute_sem=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L8-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_expect_shadow-Tuple{MPO, AbstractShadow}" href="#RandomMeas.get_expect_shadow-Tuple{MPO, AbstractShadow}"><code>RandomMeas.get_expect_shadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_expect_shadow(O::MPO, shadow::AbstractShadow)</code></pre><p>Compute the expectation value of an MPO operator <code>O</code> using a single shadow object.</p><p><strong>Arguments:</strong></p><ul><li><code>O::MPO</code>: The MPO operator for which the expectation value is computed.</li><li><code>shadow::AbstractShadow</code>: A shadow object, either dense, factorized, or shallow.</li></ul><p><strong>Returns</strong></p><p>The expectation value as a scalar.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">val = get_expect_shadow(O, shadow)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L52-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace_moment-Tuple{Matrix{&lt;:AbstractShadow}, Int64}" href="#RandomMeas.get_trace_moment-Tuple{Matrix{&lt;:AbstractShadow}, Int64}"><code>RandomMeas.get_trace_moment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace_moment(shadows::Array{&lt;:AbstractShadow, 2}, kth_moment::Int; O::Union{Nothing, MPO}=nothing)</code></pre><p>Compute a single trace moment from an array of <code>AbstractShadow</code> objects.</p><p><strong>Arguments</strong></p><ul><li><code>shadows::Array{&lt;:AbstractShadow, 2}</code>: An array of shadow objects with dimensions <code>(n_ru, n_m)</code>, where <code>n_ru</code> is the number of random unitaries and <code>n_m</code> is the number of measurements.</li><li><code>kth_moment::Int</code>: The moment <code>k</code> to compute (e.g., <code>k = 1, 2, ...</code>).</li><li><code>O::Union{Nothing, MPO}</code> (optional): If provided, computes <code>Tr[O * ρ^k]</code>; otherwise, computes <code>Tr[ρ^k]</code> (default: <code>nothing</code>).</li></ul><p><strong>Returns</strong></p><p>The computed trace moment as a scalar.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">moment1 = get_trace_moment(shadows, 1)
moment2 = get_trace_moment(shadows, 2; O=my_operator)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L82-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace_moment-Tuple{Vector{&lt;:AbstractShadow}, Int64}" href="#RandomMeas.get_trace_moment-Tuple{Vector{&lt;:AbstractShadow}, Int64}"><code>RandomMeas.get_trace_moment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace_moment(shadows::Vector{&lt;:AbstractShadow}, kth_moment::Int; O::Union{Nothing, MPO}=nothing)</code></pre><p>Wrapper function. Compute a single trace moment for a vector of shadow objects by reshaping the vector into a 2D array.</p><p><strong>Arguments</strong></p><ul><li><code>shadows::Vector{&lt;:AbstractShadow}</code>: A vector of shadow objects.</li><li><code>kth_moment::Int</code>: The moment order <code>k</code> to compute.</li><li><code>O::Union{Nothing, MPO}</code> (optional): An MPO observable.</li></ul><p><strong>Returns</strong></p><p>The computed trace moment as a scalar.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">moment = get_trace_moment(shadows_vector, 2; O=my_operator)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L132-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace_moments-Tuple{Matrix{&lt;:AbstractShadow}, Vector{Int64}}" href="#RandomMeas.get_trace_moments-Tuple{Matrix{&lt;:AbstractShadow}, Vector{Int64}}"><code>RandomMeas.get_trace_moments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace_moments(shadows::Array{&lt;:AbstractShadow, 2}, kth_moments::Vector{Int}; O::Union{Nothing, MPO}=nothing)</code></pre><p>Wrapper function. Compute multiple trace moments from an array of shadow objects.</p><p><strong>Arguments</strong></p><ul><li><code>shadows::Array{&lt;:AbstractShadow, 2}</code>: An array of shadow objects with dimensions <code>(n_ru, n_m)</code>.</li><li><code>kth_moments::Vector{Int}</code>: A vector of moment orders.</li><li><code>O::Union{Nothing, MPO}</code> (optional): An MPO observable; if provided, computes <code>Tr[O * ρ^k]</code> for each moment (default: <code>nothing</code>).</li></ul><p><strong>Returns</strong></p><p>A vector of trace moments corresponding to each moment in <code>kth_moments</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">moments = get_trace_moments(shadows_array, [1, 2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L154-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace_moments-Tuple{Vector{&lt;:AbstractShadow}, Vector{Int64}}" href="#RandomMeas.get_trace_moments-Tuple{Vector{&lt;:AbstractShadow}, Vector{Int64}}"><code>RandomMeas.get_trace_moments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace_moments(shadows::Vector{&lt;:AbstractShadow}, kth_moments::Vector{Int}; O::Union{Nothing, MPO}=nothing)</code></pre><p>Wrapper function. Compute multiple trace moments from a vector of shadow objects by reshaping the vector into a 2D array.</p><p><strong>Arguments</strong></p><ul><li><code>shadows::Vector{&lt;:AbstractShadow}</code>: A vector of shadow objects.</li><li><code>kth_moments::Vector{Int}</code>: A vector of moment orders.</li><li><code>O::Union{Nothing, MPO}</code> (optional): An MPO observable.</li></ul><p><strong>Returns</strong></p><p>A vector of trace moments.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">moments = get_trace_moments(shadows_vector, [1, 2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L176-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace_product-Tuple{Vararg{AbstractShadow}}" href="#RandomMeas.get_trace_product-Tuple{Vararg{AbstractShadow}}"><code>RandomMeas.get_trace_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace_product(shadows::AbstractShadow...; O::Union{Nothing, MPO}=nothing)</code></pre><p>Compute the product of multiple shadow objects and return its trace or expectation value.</p><p>If <code>O</code> is <code>nothing</code>, returns the trace of the product:     trace(shadow₁ * shadow₂ * ... * shadowₙ). If <code>O</code> is provided, returns the expectation value computed by:     get<em>expect</em>shadow(O, shadow₁ * shadow₂ * ... * shadowₙ).</p><p><strong>Arguments</strong></p><ul><li><code>shadows...</code>: A variable number of shadow objects.</li><li><code>O::Union{Nothing, MPO}</code> (optional): An MPO observable.</li></ul><p><strong>Returns</strong></p><p>The trace of the product if <code>O</code> is <code>nothing</code>, or the expectation value if <code>O</code> is provided.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = get_trace_product(shadow1, shadow2, shadow3)
result_with_O = get_trace_product(shadow1, shadow2, shadow3; O=my_operator)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L199-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.multiply-Tuple{AbstractShadow, AbstractShadow}" href="#RandomMeas.multiply-Tuple{AbstractShadow, AbstractShadow}"><code>RandomMeas.multiply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply(shadow1::AbstractShadow, shadow2::AbstractShadow)</code></pre><p>Multiply two shadow objects of the same concrete type.</p><p><strong>Arguments:</strong></p><ul><li><code>shadow1::AbstractShadow</code>: The first shadow object.</li><li><code>shadow2::AbstractShadow</code>: The second shadow object.</li></ul><p><strong>Returns</strong></p><p>A new shadow object representing the product.</p><p><strong>Throws</strong></p><p>An <code>ArgumentError</code> if the types of <code>shadow1</code> and <code>shadow2</code> do not match.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prod_shadow = multiply(shadow1, shadow2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L234-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_trace-Tuple{AbstractArray{&lt;:AbstractShadow}, Vector{Int64}}" href="#RandomMeas.partial_trace-Tuple{AbstractArray{&lt;:AbstractShadow}, Vector{Int64}}"><code>RandomMeas.partial_trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_trace(shadows::AbstractArray{&lt;:AbstractShadow}, subsystem::Vector{Int})</code></pre><p>Compute the partial trace for each shadow in a collection of shadows.</p><p><strong>Arguments</strong></p><ul><li><code>shadows::AbstractArray{&lt;:AbstractShadow}</code>: A collection of shadow objects (vector or 2D array).</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem to retain.</li></ul><p><strong>Returns</strong></p><p>An array of shadows reduced to the specified subsystem, with the same dimensions as the input array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L334-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_trace-Tuple{AbstractShadow, Vector{Int64}}" href="#RandomMeas.partial_trace-Tuple{AbstractShadow, Vector{Int64}}"><code>RandomMeas.partial_trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_trace(shadow::AbstractShadow, subsystem::Vector{Int}; assume_unit_trace::Bool=false)</code></pre><p>Compute the partial trace of a shadow object over the complement of the specified subsystem.</p><p><strong>Arguments</strong></p><ul><li><code>shadow::AbstractShadow</code>: The shadow object.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem to retain.</li><li><code>assume_unit_trace::Bool</code> (optional): If <code>true</code>, assumes the shadow has unit trace (default: <code>false</code>).   This can speed up the calculation for factorized shadows (as the trace of &quot;traced out&quot; qubits is not computed)/</li></ul><p><strong>Returns</strong></p><p>A new shadow object reduced to the specified subsystem.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">reduced_shadow = partial_trace(shadow, [1, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L305-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_transpose-Tuple{AbstractArray{&lt;:AbstractShadow}, Vector{Int64}}" href="#RandomMeas.partial_transpose-Tuple{AbstractArray{&lt;:AbstractShadow}, Vector{Int64}}"><code>RandomMeas.partial_transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_transpose(shadows::AbstractArray{&lt;:AbstractShadow}, subsystem::Vector{Int})</code></pre><p>Compute the partial transpose for each shadow in a collection.</p><p><strong>Arguments</strong></p><ul><li><code>shadows::AbstractArray{&lt;:AbstractShadow}</code>: A collection (vector or 2D array) of shadow objects.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem(s) over which the transpose is to be performed.</li></ul><p><strong>Returns</strong></p><p>An array of shadow objects with the partial transpose applied, preserving the input dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L386-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_transpose-Tuple{AbstractShadow, Vector{Int64}}" href="#RandomMeas.partial_transpose-Tuple{AbstractShadow, Vector{Int64}}"><code>RandomMeas.partial_transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_transpose(shadow::AbstractShadow, subsystem::Vector{Int})</code></pre><p>Compute the partial transpose of a shadow object over the specified subsystem(s). This operation is analogous to QuTiP&#39;s partial transpose method.</p><p><strong>Arguments</strong></p><ul><li><code>shadow::AbstractShadow</code>: The shadow object for which the partial transpose is computed.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem(s) over which to perform the transpose.</li></ul><p><strong>Returns</strong></p><p>A new shadow object that is the partial transpose of the input.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">transposed_shadow = partial_transpose(shadow, [2, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L358-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.trace-Tuple{AbstractArray{&lt;:AbstractShadow}}" href="#RandomMeas.trace-Tuple{AbstractArray{&lt;:AbstractShadow}}"><code>RandomMeas.trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(shadows::AbstractArray{&lt;:AbstractShadow})</code></pre><p>Compute the trace for each shadow in a collection of shadow objects.</p><p><strong>Arguments:</strong></p><ul><li><code>shadows::AbstractArray{&lt;:AbstractShadow}</code>: A collection (vector, matrix, etc.) of shadow objects.</li></ul><p><strong>Returns</strong></p><p>An array of scalar trace values corresponding to each shadow, with the same dimensions as the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L288-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.trace-Tuple{AbstractShadow}" href="#RandomMeas.trace-Tuple{AbstractShadow}"><code>RandomMeas.trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(shadow::AbstractShadow)</code></pre><p>Compute the trace of a shadow object.</p><p><strong>Arguments:</strong></p><ul><li><code>shadow::AbstractShadow</code>: A shadow object.</li></ul><p><strong>Returns</strong></p><p>The trace of the shadow object as a scalar.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">t = trace(shadow)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/AbstractShadows.jl#L263-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.FactorizedShadow-Tuple{Vector{Int64}, Vector{ITensor}}" href="#RandomMeas.FactorizedShadow-Tuple{Vector{Int64}, Vector{ITensor}}"><code>RandomMeas.FactorizedShadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FactorizedShadow(measurement_results::Vector{Int}, local_unitary::Vector{ITensor};
                 G::Vector{Float64} = fill(1.0, length(local_unitary)))</code></pre><p>Construct a <code>FactorizedShadow</code> object from raw measurement results and unitary transformations.</p><p><strong>Arguments</strong></p><ul><li><code>measurement_results::Vector{Int}</code>: Vector of binary measurement results for each qubit/site.</li><li><code>local_unitary::Vector{ITensor}</code>: Vector of local unitary transformations applied during the measurement.</li><li>G::Vector{Float64}<code>(optional): Vector of</code>G` values for measurement error correction (default: 1.0 for all sites).</li></ul><p><strong>Returns</strong></p><p>A <code>FactorizedShadow</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.convert_to_dense_shadow-Tuple{FactorizedShadow}" href="#RandomMeas.convert_to_dense_shadow-Tuple{FactorizedShadow}"><code>RandomMeas.convert_to_dense_shadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_to_dense_shadow(factorized_shadow::FactorizedShadow)</code></pre><p>Convert a <code>FactorizedShadow</code> object into a <code>DenseShadow</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>factorized_shadow::FactorizedShadow</code>: The <code>FactorizedShadow</code> object to convert.</li></ul><p><strong>Returns</strong></p><p>A <code>DenseShadow</code> object with the combined ITensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L272-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_expect_shadow-Tuple{MPO, FactorizedShadow}" href="#RandomMeas.get_expect_shadow-Tuple{MPO, FactorizedShadow}"><code>RandomMeas.get_expect_shadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_expect_shadow(O::MPO, shadow::FactorizedShadow)</code></pre><p>Compute the expectation value of an MPO operator <code>O</code> using a factorized shadow.</p><p><strong>Arguments:</strong></p><ul><li><code>O::MPO</code>: The MPO operator for which the expectation value is computed.</li><li><code>shadow::FactorizedShadow</code>: A factorized shadow object.</li></ul><p><strong>Returns:</strong></p><p>The expectation value as a <code>ComplexF64</code> (or <code>Float64</code> if purely real).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L105-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_factorized_shadows-Tuple{MeasurementData{LocalUnitaryMeasurementSetting}}" href="#RandomMeas.get_factorized_shadows-Tuple{MeasurementData{LocalUnitaryMeasurementSetting}}"><code>RandomMeas.get_factorized_shadows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_factorized_shadows(measurement_data::MeasurementData{LocalUnitaryMeasurementSetting};
                       G::Vector{Float64} = fill(1.0, measurement_data.N))</code></pre><p>Compute factorized shadows for all measurement results in the provided <code>MeasurementData</code>.</p><p><strong>Arguments</strong></p><ul><li><code>measurement_data::MeasurementData{LocalUnitaryMeasurementSetting}</code>: Measurement data object containing measurement results and settings.</li><li><code>G::Vector{Float64}</code> (optional): Vector of <code>G</code> values for measurement error correction (default: 1.0 for all sites).</li></ul><p><strong>Returns</strong></p><p>A Vector of NM <code>FactorizedShadow</code> objects with dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_factorized_shadows-Tuple{MeasurementGroup{LocalUnitaryMeasurementSetting}}" href="#RandomMeas.get_factorized_shadows-Tuple{MeasurementGroup{LocalUnitaryMeasurementSetting}}"><code>RandomMeas.get_factorized_shadows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_factorized_shadows(measurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting};
                       G::Vector{Float64} = fill(1.0, measurement_group.N))</code></pre><p>Compute factorized shadows for all measurement results in the provided <code>MeasurementGroup</code>.</p><p><strong>Arguments</strong></p><ul><li><code>measurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting}</code>: Measurement data object containing measurement results and settings.</li><li><code>G::Vector{Float64}</code> (optional): Vector of <code>G</code> values for measurement error correction (default: 1.0 for all sites).</li></ul><p><strong>Returns</strong></p><p>A Array of NU*NM <code>FactorizedShadow</code> objects with dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L78-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.multiply-Tuple{FactorizedShadow, FactorizedShadow}" href="#RandomMeas.multiply-Tuple{FactorizedShadow, FactorizedShadow}"><code>RandomMeas.multiply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply(shadow1::FactorizedShadow, shadow2::FactorizedShadow)</code></pre><p>Multiply two <code>FactorizedShadow</code> objects element-wise.</p><p><strong>Arguments</strong></p><ul><li><code>shadow1::FactorizedShadow</code>: The first <code>FactorizedShadow</code> object.</li><li><code>shadow2::FactorizedShadow</code>: The second <code>FactorizedShadow</code> object.</li></ul><p><strong>Returns</strong></p><p>A new <code>FactorizedShadow</code> object representing the element-wise product of the two inputs.</p><p><strong>Notes</strong></p><ul><li>Both <code>shadow1</code> and <code>shadow2</code> must have the same number of qubits/sites.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L130-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_trace-Tuple{FactorizedShadow, Vector{Int64}}" href="#RandomMeas.partial_trace-Tuple{FactorizedShadow, Vector{Int64}}"><code>RandomMeas.partial_trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_trace(shadow::FactorizedShadow, subsystem::Vector{Int}; assume_unit_trace::Bool = false)</code></pre><p>Compute the partial trace of a <code>FactorizedShadow</code> object over the complement of the specified subsystem.</p><p><strong>Arguments</strong></p><ul><li><code>shadow::FactorizedShadow</code>: The factorized shadow to compute the partial trace for.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem to retain.</li><li><code>assume_unit_trace::Bool</code> (optional): If <code>true</code>, assumes all traced-out tensors have unit trace and skips explicit computation (default: <code>false</code>).</li></ul><p><strong>Returns</strong></p><p>A new <code>FactorizedShadow</code> object reduced to the specified subsystem.</p><p><strong>Notes</strong></p><ul><li>If <code>assume_unit_trace</code> is <code>true</code>, avoids explicit trace computation for efficiency.</li><li>If <code>assume_unit_trace</code> is <code>false</code>, computes the traces of all tensors outside the subsystem and multiplies their product into the remaining tensors.</li><li>Issues a warning if the trace product deviates significantly from 1 when <code>assume_unit_trace</code> is <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L188-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_transpose-Tuple{FactorizedShadow, Vector{Int64}}" href="#RandomMeas.partial_transpose-Tuple{FactorizedShadow, Vector{Int64}}"><code>RandomMeas.partial_transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_transpose(shadow::FactorizedShadow, subsystem::Vector{Int})::FactorizedShadow</code></pre><p>Compute the partial transpose of a FactorizedShadow over the specified subsystem by swapping, for each site, the unprimed and primed indices using the <code>swapind</code> function. This function returns views of the underlying ITensors, avoiding unnecessary data duplication.</p><p><strong>Arguments</strong></p><ul><li><code>shadow::FactorizedShadow</code>: The factorized classical shadow.</li><li><code>subsystem::Vector{Int}</code>: A vector of 1-based site indices on which to perform the partial transpose.</li></ul><p><strong>Returns</strong></p><p>A new FactorizedShadow with the specified sites partially transposed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L244-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.trace-Tuple{FactorizedShadow}" href="#RandomMeas.trace-Tuple{FactorizedShadow}"><code>RandomMeas.trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(shadow::FactorizedShadow)</code></pre><p>Compute the trace of a <code>FactorizedShadow</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>shadow::FactorizedShadow</code>: The <code>FactorizedShadow</code> object whose trace is to be computed.</li></ul><p><strong>Returns</strong></p><p>The trace of the shadow as a <code>Float64</code> or <code>ComplexF64</code>.</p><p><strong>Notes</strong></p><ul><li>The function computes the product of the traces of individual tensors in the factorized shadow.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/FactorizedShadows.jl#L160-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.DenseShadow-Tuple{MeasurementData{LocalUnitaryMeasurementSetting}}" href="#RandomMeas.DenseShadow-Tuple{MeasurementData{LocalUnitaryMeasurementSetting}}"><code>RandomMeas.DenseShadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseShadow(measurement_data::MeasurementData{LocalUnitaryMeasurementSetting}; G::Vector{Float64} = fill(1.0, size(measurement_data.N, 2)))</code></pre><p>Construct a <code>DenseShadow</code> object from a MeasurementDataObject</p><p><strong>Arguments</strong></p><ul><li>`measurement_data::MeasurementData{LocalUnitaryMeasurementSetting}:</li><li><code>G::Vector{Float64}</code> (optional): Vector of G values to account for measurement errors (default: 1.0 for all sites).</li></ul><p><strong>Returns</strong></p><p>A <code>DenseShadow</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/DenseShadows.jl#L43-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.DenseShadow-Tuple{MeasurementProbability{LocalUnitaryMeasurementSetting}}" href="#RandomMeas.DenseShadow-Tuple{MeasurementProbability{LocalUnitaryMeasurementSetting}}"><code>RandomMeas.DenseShadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseShadow(measurement_probability::MeasurementProbability; G::Vector{Float64} = fill(1.0, length(u)))</code></pre><p>Construct a <code>DenseShadow</code> object from a precomputed probability tensor.</p><p><strong>Arguments</strong></p><ul><li><code>P::ITensor</code>: Probability tensor representing measurement results.</li><li><code>u::Vector{ITensor}</code>: Vector of local unitary transformations.</li><li><code>G::Vector{Float64}</code> (optional): Vector of G values to account for measurement errors (default: 1.0 for all sites).</li></ul><p><strong>Returns</strong></p><p>A <code>DenseShadow</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/DenseShadows.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_dense_shadows-Tuple{MeasurementGroup{LocalUnitaryMeasurementSetting}}" href="#RandomMeas.get_dense_shadows-Tuple{MeasurementGroup{LocalUnitaryMeasurementSetting}}"><code>RandomMeas.get_dense_shadows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_dense_shadows(measurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting};
                  G::Vector{Float64} = fill(1.0, N),
                  number_of_ru_batches::Int = NU)</code></pre><p>Compute dense shadows for the provided measurement data in batches.</p><p><strong>Arguments</strong></p><ul><li><code>measurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting}</code>: Measurement data object.</li><li><code>G::Vector{Float64}</code> (optional): Vector of G values for robustness (default: 1.0 for all sites).</li><li><code>number_of_ru_batches::Int</code> (optional): Number of random unitary batches (default: <code>NU</code>).</li></ul><p><strong>Returns</strong></p><p>A Vector of <code>DenseShadow</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/DenseShadows.jl#L62-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_expect_shadow-Tuple{MPO, DenseShadow}" href="#RandomMeas.get_expect_shadow-Tuple{MPO, DenseShadow}"><code>RandomMeas.get_expect_shadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_expect_shadow(O::MPO, shadow::DenseShadow)</code></pre><p>Compute the expectation value of an MPO operator <code>O</code> using a dense shadow.</p><p><strong>Arguments:</strong></p><ul><li><code>O::MPO</code>: The MPO operator for which the expectation value is computed.</li><li><code>shadow::DenseShadow</code>: A dense shadow object.</li></ul><p><strong>Returns:</strong></p><p>The expectation value as a <code>ComplexF64</code> (or <code>Float64</code> if purely real).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/DenseShadows.jl#L112-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.multiply-Tuple{DenseShadow, DenseShadow}" href="#RandomMeas.multiply-Tuple{DenseShadow, DenseShadow}"><code>RandomMeas.multiply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply(shadow1::DenseShadow, shadow2::DenseShadow)</code></pre><p>Compute the trace product of two dense shadows.</p><p><strong>Arguments</strong></p><ul><li><code>shadow1::DenseShadow</code>: The first dense shadow.</li><li><code>shadow2::DenseShadow</code>: The second dense shadow.</li></ul><p><strong>Returns</strong></p><p>A new <code>DenseShadow</code> object that represents the trace product of the two input shadows.</p><p><strong>Notes</strong></p><ul><li>The shadows must have the same site indices (<code>ξ</code>) and number of qubits (<code>N</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/DenseShadows.jl#L137-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_trace-Tuple{DenseShadow, Vector{Int64}}" href="#RandomMeas.partial_trace-Tuple{DenseShadow, Vector{Int64}}"><code>RandomMeas.partial_trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_trace(shadow::DenseShadow, subsystem::Vector{Int})</code></pre><p>Compute the partial trace of a <code>DenseShadow</code> object over the complement of the specified subsystem.</p><p><strong>Arguments</strong></p><ul><li><code>shadow::DenseShadow</code>: The dense shadow to compute the partial trace for.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) specifying the subsystem to retain.</li></ul><p><strong>Returns</strong></p><p>A new <code>DenseShadow</code> object reduced to the specified subsystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/DenseShadows.jl#L193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_transpose-Tuple{DenseShadow, Vector{Int64}}" href="#RandomMeas.partial_transpose-Tuple{DenseShadow, Vector{Int64}}"><code>RandomMeas.partial_transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_transpose(shadow::DenseShadow, subsystem::Vector{Int})::DenseShadow</code></pre><p>Compute the partial transpose of a DenseShadow over the specified subsystem by swapping, for each site, the unprimed index with its primed partner. This is done using the <code>swapind</code> function, which returns a view of the underlying ITensor.</p><p><strong>Arguments</strong></p><ul><li><code>shadow::DenseShadow</code>: The dense classical shadow.</li><li><code>subsystem::Vector{Int}</code>: A vector of 1-based site indices on which to perform the partial transpose.</li></ul><p><strong>Returns</strong></p><p>A new DenseShadow with the specified sites partially transposed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/DenseShadows.jl#L228-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.trace-Tuple{DenseShadow}" href="#RandomMeas.trace-Tuple{DenseShadow}"><code>RandomMeas.trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(shadow::DenseShadow)</code></pre><p>Compute the trace of a <code>DenseShadow</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>shadow::DenseShadow</code>: The <code>DenseShadow</code> object whose trace is to be computed.</li></ul><p><strong>Returns</strong></p><p>The trace of the shadow as a <code>Float64</code> or <code>ComplexF64</code>.</p><p><strong>Notes</strong></p><ul><li>The function contracts the <code>ξ</code> and <code>ξ&#39;</code> indices of the shadow&#39;s ITensor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/DenseShadows.jl#L164-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.ShallowShadow-Tuple{Vector{Int64}, Vector{ITensor}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}" href="#RandomMeas.ShallowShadow-Tuple{Vector{Int64}, Vector{ITensor}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}"><code>RandomMeas.ShallowShadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShallowShadow(measurement_results::Vector{Int}, local_unitary::Vector{ITensor};
                 G::Vector{Float64} = fill(1.0, length(local_unitary)))</code></pre><p>Construct a <code>ShallowSShadow</code> object from raw measurement results and unitary transformations.</p><p><strong>Arguments</strong></p><ul><li><code>measurement_results::Vector{Int}</code>: Vector of binary measurement results for each qubit/site.</li><li><code>local_unitary::Vector{ITensor}</code>: Vector of local unitary transformations applied during the measurement.</li></ul><p><strong>Returns</strong></p><p>A <code>ShallowShadow</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShallowShadows.jl#L111-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.apply_map-Tuple{Vector{ITensor}, MPO, Vector{Index{Int64}}, Vector{Index{Int64}}}" href="#RandomMeas.apply_map-Tuple{Vector{ITensor}, MPO, Vector{Index{Int64}}, Vector{Index{Int64}}}"><code>RandomMeas.apply_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_map(map::MPO,state::MPO,s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})</code></pre><p>Apply a map map((s,s&#39;)→(ξ,ξ&#39;)) on a state of indices (ξ,ξ&#39;)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShallowShadows.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_depolarization_map-Tuple{MPS, Vector{Index{Int64}}, Vector{Index{Int64}}}" href="#RandomMeas.get_depolarization_map-Tuple{MPS, Vector{Index{Int64}}, Vector{Index{Int64}}}"><code>RandomMeas.get_depolarization_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_depolarization_map(depolarization_mps::MPS,s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})</code></pre><p>returns a shallow map \mathcal{M} parametrization by a depolarization<em>mps c(\nu)  where the state is depolarized over partition \A</em>{ u} with probability c(\nu)=1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShallowShadows.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_depolarization_map-Tuple{Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}, Vector{Index{Int64}}}" href="#RandomMeas.get_depolarization_map-Tuple{Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}, Vector{Index{Int64}}}"><code>RandomMeas.get_depolarization_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_depolarization_map(depolarization_mps::MPS,s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})</code></pre><p>returns a shallow map \mathcal{M} parametrization by a depolarization<em>mps c(\nu)  where the state is depolarized over partition \A</em>{ u} with probability c(\nu)=1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShallowShadows.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_expect_shadow-Tuple{MPO, MeasurementData{ShallowUnitaryMeasurementSetting}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}" href="#RandomMeas.get_expect_shadow-Tuple{MPO, MeasurementData{ShallowUnitaryMeasurementSetting}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}"><code>RandomMeas.get_expect_shadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_expect_shadow(O::MPO, measurement_data::MeasurementData{ShallowUnitaryMeasurementSetting}, inverse_shallow_map::Vector{ITensor},s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})</code></pre><p>Compute the expectation value of an MPO operator <code>O</code> from a shallow MeasurementData and and inverse shallow_map</p><p><strong>Returns:</strong></p><p>The expectation value as a <code>ComplexF64</code> (or <code>Float64</code> if purely real).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShallowShadows.jl#L194-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_expect_shadow-Tuple{MPO, ShallowShadow}" href="#RandomMeas.get_expect_shadow-Tuple{MPO, ShallowShadow}"><code>RandomMeas.get_expect_shadow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_expect_shadow(O::MPO, shadow::ShallowShadow)</code></pre><p>Compute the expectation value of an MPO operator <code>O</code> using a shallow shadow.</p><p><strong>Arguments:</strong></p><ul><li><code>O::MPO</code>: The MPO operator for which the expectation value is computed.</li><li><code>shadow::ShallowShadow</code>: A factorized shadow object.</li></ul><p><strong>Returns:</strong></p><p>The expectation value as a <code>ComplexF64</code> (or <code>Float64</code> if purely real).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShallowShadows.jl#L170-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_shallow_depolarization_mps-Tuple{MeasurementGroup{ShallowUnitaryMeasurementSetting}}" href="#RandomMeas.get_shallow_depolarization_mps-Tuple{MeasurementGroup{ShallowUnitaryMeasurementSetting}}"><code>RandomMeas.get_shallow_depolarization_mps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_shallow_depolarization_mps(group::MeasurementGroup{ShallowUnitaryMeasurementSetting})</code></pre><p>TBW</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShallowShadows.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_shallow_shadows-Tuple{MeasurementData{ShallowUnitaryMeasurementSetting}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}" href="#RandomMeas.get_shallow_shadows-Tuple{MeasurementData{ShallowUnitaryMeasurementSetting}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}"><code>RandomMeas.get_shallow_shadows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_shallow_shadows(measurement_data::MeasurementData{ShallowUnitaryMeasurementSetting}, inverse_shallow_map::Vector{ITensor},s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})</code></pre><p>Construct a <code>ShallowSShadow</code> object from MeasurementData</p><p><strong>Arguments</strong></p><p><strong>Returns</strong></p><p>A <code>ShallowShadow</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/ShallowShadows.jl#L144-L154">source</a></section></article><h2 id="Simulating-quantum-circuits"><a class="docs-heading-anchor" href="#Simulating-quantum-circuits">Simulating quantum circuits</a><a id="Simulating-quantum-circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-quantum-circuits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.apply_depo_channel-Tuple{MPO, Vector{Float64}}" href="#RandomMeas.apply_depo_channel-Tuple{MPO, Vector{Float64}}"><code>RandomMeas.apply_depo_channel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_depo_channel(ρ::MPO, p::Vector{Float64})</code></pre><p>Apply a local depolarization channel to an MPO by modifying each site tensor according to the depolarization probability.</p><p>For each site, the channel acts as:</p><p>ρ[i] → (1 - p[i]) * ρ[i] + (p[i] / 2) * (ρ[i] * δ(s, s&#39;) * δ(s, s&#39;))</p><p>where δ(s, s&#39;) is the delta tensor that contracts the site index with its primed counterpart.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::MPO</code>: The input Matrix Product Operator representing a density matrix.</li><li><code>p::Vector{Float64}</code>: A vector of depolarization probabilities, one per site.</li></ul><p><strong>Returns</strong></p><p>An MPO with the depolarization channel applied on each site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Circuits.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.apply_depo_channel-Tuple{MPS, Vector{Float64}}" href="#RandomMeas.apply_depo_channel-Tuple{MPS, Vector{Float64}}"><code>RandomMeas.apply_depo_channel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_depo_channel(ψ::MPS, p::Vector{Float64})</code></pre><p>Apply the local depolarization channel to an MPS by converting it to an MPO density matrix (using the outer product) and then applying the depolarization channel.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::MPS</code>: The input Matrix Product State representing a pure state.</li><li><code>p::Vector{Float64}</code>: A vector of depolarization probabilities, one per site.</li></ul><p><strong>Returns</strong></p><p>An MPO representing the depolarized density matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Circuits.jl#L31-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.random_Pauli_layer-Tuple{Vector{Index{Int64}}, Vector{Float64}}" href="#RandomMeas.random_Pauli_layer-Tuple{Vector{Index{Int64}}, Vector{Float64}}"><code>RandomMeas.random_Pauli_layer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_Pauli_layer(ξ::Vector{Index{Int64}}, p::Vector{Float64})</code></pre><p>Construct a layer of random single-qubit Pauli operations to simulate local depolarization. Upon avereraging, this corresponds to the local depolarization channel with strength p.</p><p>For each qubit (with index i), a random Pauli operation is applied with the following probabilities:</p><ul><li>With probability 1 - 3p_i/4: No operation is applied (the qubit remains unchanged).</li><li>With probability p_i/4} each: Apply the X, Y, or Z gate.</li></ul><p>Here, p_i is the depolarization probability for qubit i.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::Vector{Index{Int64}}</code>: A vector of ITensor indices representing the qubit sites.</li><li><code>p::Vector{Float64}</code>: A vector of depolarization probabilities (one per qubit).</li></ul><p><strong>Returns</strong></p><p>A vector of ITensors representing the applied Pauli gates. If no gate is applied on a site (with probability 1 - 3p_i/4, that site is omitted from the returned circuit.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">circuit = random_Pauli_layer(siteinds(&quot;Qubit&quot;, 5), 0.05 * ones(5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Circuits.jl#L94-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.random_circuit-Tuple{Vector{Index{Int64}}, Int64}" href="#RandomMeas.random_circuit-Tuple{Vector{Index{Int64}}, Int64}"><code>RandomMeas.random_circuit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_circuit(ξ::Vector{Index{Int64}}, depth::Int64)</code></pre><p>Create a random circuit of the given depth. The function returns a vector of ITensors, each representing a gate in the circuit.</p><ul><li>If <code>depth == 0</code>, a single-qubit random unitary is applied to each site.</li><li>For <code>depth &gt; 0</code>, the circuit is built layer-by-layer:<ul><li>On odd layers, random two-qubit gates are applied on sites 1-2, 3-4, etc.</li><li>On even layers, random two-qubit gates are applied on sites 2-3, 4-5, etc.</li></ul></li></ul><p><strong>Arguments</strong></p><ul><li><code>ξ::Vector{Index{Int64}}</code>: A vector of site indices for the qubits.</li><li><code>depth::Int64</code>: The depth of the circuit (non-negative integer).</li></ul><p><strong>Returns</strong></p><p>A vector of ITensors representing the random circuit gates.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">circuit = random_circuit(siteinds(&quot;Qubit&quot;, 10), 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Circuits.jl#L48-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.random_magnetic_field_layer-Tuple{Vector{Index{Int64}}, Vector{Float64}}" href="#RandomMeas.random_magnetic_field_layer-Tuple{Vector{Index{Int64}}, Vector{Float64}}"><code>RandomMeas.random_magnetic_field_layer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_magnetic_field_layer(ξ::Vector{Index{Int64}}, p::Vector{Float64})</code></pre><p>Construct a layer of random Rz gates representing a random magnetic field along the z-axis.</p><p>For each qubit i, a random rotation Rz is applied with a rotation angle drawn uniformly from [0, 2 pi p<em>i). This gives an average rotation angle of pi p</em>i on each site.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::Vector{Index{Int64}}</code>: A vector of ITensor indices corresponding to the qubit sites.</li><li><code>p::Vector{Float64}</code>: A vector of parameters (one per qubit) that set the scale of the rotation angles.</li></ul><p><strong>Returns</strong></p><p>A vector of ITensors representing the random Rz gates applied to each qubit.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">circuit = random_magnetic_field_layer(siteinds(&quot;Qubit&quot;, 5), 0.1 * ones(5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/Circuits.jl#L135-L154">source</a></section></article><h2 id="Additional-useful-routines-for-ITensor"><a class="docs-heading-anchor" href="#Additional-useful-routines-for-ITensor">Additional useful routines for ITensor</a><a id="Additional-useful-routines-for-ITensor-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-useful-routines-for-ITensor" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.flatten-Tuple{Union{MPO, MPS, Vector{ITensor}}}" href="#RandomMeas.flatten-Tuple{Union{MPO, MPS, Vector{ITensor}}}"><code>RandomMeas.flatten</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flatten(O::Union{MPS, MPO, Vector{ITensor}})</code></pre><p>Flatten a Matrix Product State (MPS), Matrix Product Operator (MPO), or a vector of ITensors into a single ITensor by sequentially multiplying the constituent tensors.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: An MPS, MPO, or vector of ITensors to be flattened.</li></ul><p><strong>Returns</strong></p><p>An ITensor representing the product of the individual tensors in <code>O</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = random_mps(siteinds(&quot;Qubit&quot;, 5))
flatA = flatten(A)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_Born_MPS-Tuple{MPO}" href="#RandomMeas.get_Born_MPS-Tuple{MPO}"><code>RandomMeas.get_Born_MPS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Born_MPS(ρ::MPO)</code></pre><p>Construct the Born probability vector as an MPS from an MPO representation of a density matrix ρ.</p><p>This function computes the Born probability vector P(s) = ⟨s|ρ|s⟩, where |s⟩ is a basis state. It does so by contracting each tensor of the MPO ρ with appropriate delta tensors that enforce equality between the unprimed and primed indices. The result is returned as an MPS that represents the Born probabilities over the computational basis.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::MPO</code>: A Matrix Product Operator representing the density matrix.</li></ul><p><strong>Returns</strong></p><p>An MPS representing the Born probability vector.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">P = get_Born_MPS(ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L368-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_Born_MPS-Tuple{MPS}" href="#RandomMeas.get_Born_MPS-Tuple{MPS}"><code>RandomMeas.get_Born_MPS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Born_MPS(ψ::MPS)</code></pre><p>Construct the Born probability vector P(s) = |ψ(s)|² as an MPS from an MPS representation ψ.</p><p>This function computes the probability for each computational basis state by contracting each tensor of the MPS ψ with its complex conjugate, using appropriate delta tensors to enforce index equality. The resulting MPS represents the Born probability distribution of the state.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::MPS</code>: A matrix product state representing a pure quantum state.</li></ul><p><strong>Returns</strong></p><p>An MPS representing the Born probability vector, where each tensor P[i] corresponds to the probability contribution at site i.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">P = get_Born_MPS(ψ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L398-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_average_mps-Tuple{Vector{MPS}, Int64, Int64}" href="#RandomMeas.get_average_mps-Tuple{Vector{MPS}, Int64, Int64}"><code>RandomMeas.get_average_mps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_average_mps(ψ_list::Vector{MPS}, χ::Int64, nsweeps::Int64)</code></pre><p>Approximate the average state σ from a collection of MPS using a DMRG-like algorithm.</p><p>The algorithm finds an MPS ψ (with maximum bond dimension χ) that approximates the average state σ = Average(ψ_list). To monitor convergence, it tracks a cost function defined as:</p><pre><code class="nohighlight hljs">cost_function = ⟨ψ|ψ⟩ - ⟨ψ|σ⟩ - ⟨σ|ψ⟩,</code></pre><p>which is equivalent to (||σ - ψ||² - ⟨σ|σ⟩).</p><p><strong>Arguments</strong></p><ul><li><code>ψ_list::Vector{MPS}</code>: A vector of MPS objects representing individual quantum states.</li><li><code>χ::Int64</code>: The desired maximum bond dimension for the averaged MPS.</li><li><code>nsweeps::Int64</code>: The number of sweeps (iterations) to perform in the DMRG-like algorithm.</li></ul><p><strong>Returns</strong></p><p>An MPS representing the approximate average state with bond dimension χ.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">avg_state = get_average_mps(ψ_list, 20, 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L457-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_entanglement_spectrum-Tuple{MPS, Int64}" href="#RandomMeas.get_entanglement_spectrum-Tuple{MPS, Int64}"><code>RandomMeas.get_entanglement_spectrum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_entanglement_spectrum(ψ::MPS, NA::Int64)</code></pre><p>Compute the entanglement spectrum for the bipartition defined by the first <code>NA</code> sites of the MPS <code>ψ</code>.</p><p>This function first creates a copy of <code>ψ</code> and orthogonalizes it up to site <code>NA</code>. Then, it performs an SVD on the tensor at site <code>NA</code>:</p><ul><li>If <code>NA &gt; 1</code>, the SVD is taken with respect to the indices corresponding to the link between sites <code>NA-1</code> and <code>NA</code> and the physical index at site <code>NA</code>.</li><li>If <code>NA == 1</code>, only the physical index at site <code>NA</code> is used.</li></ul><p>The returned object <code>spec</code> contains the singular values (which are related to the Schmidt coefficients) for the bipartition.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::MPS</code>: A matrix product state representing a pure quantum state.</li><li><code>NA::Int64</code>: The number of sites from the left that define the subsystem for which the entanglement spectrum is computed.</li></ul><p><strong>Returns</strong></p><ul><li><code>spec</code>: An ITensor containing the singular values from the SVD at site <code>NA</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">spectrum = get_entanglement_spectrum(ψ, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L229-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_selfXEB-Tuple{MPS}" href="#RandomMeas.get_selfXEB-Tuple{MPS}"><code>RandomMeas.get_selfXEB</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_selfXEB(ψ::MPS)</code></pre><p>Compute the self-XEB (cross-entropy benchmarking) metric for a pure state represented as an MPS.</p><p>The self-XEB is defined as:</p><pre><code class="nohighlight hljs">selfXEB = 2^N * ∑ₛ |ψ(s)|⁴ - 1</code></pre><p>where the sum is over all computational basis states s and N is the number of sites (qubits). This function first computes the Born probability MPS from ψ, then calculates the inner product of the probability MPS with itself, scales the result by 2^N, and finally subtracts 1.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::MPS</code>: A Matrix Product State representing a pure quantum state.</li></ul><p><strong>Returns</strong></p><p>A scalar (Float64) representing the self-XEB value.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = get_selfXEB(ψ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L429-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_siteinds-Tuple{Union{MPO, MPS}}" href="#RandomMeas.get_siteinds-Tuple{Union{MPO, MPS}}"><code>RandomMeas.get_siteinds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_siteinds(ψ::Union{MPS, MPO})</code></pre><p>Retrieve the site indices for a quantum state represented as an MPS or MPO.</p><p><strong>Arguments</strong></p><ul><li><code>ψ</code>: The quantum state, which can be either a Matrix Product State (MPS) or a Matrix Product Operator (MPO).</li></ul><p><strong>Returns</strong></p><p>A vector of site indices corresponding to the quantum state <code>ψ</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ξ = get_siteinds(ψ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace-Tuple{MPO}" href="#RandomMeas.get_trace-Tuple{MPO}"><code>RandomMeas.get_trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace(ρ::MPO)</code></pre><p>Compute the trace of a Matrix Product Operator (MPO) ρ by contracting each tensor with a delta function that equates its unprimed and primed indices.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::MPO</code>: A matrix product operator representing a quantum state or operator.</li></ul><p><strong>Returns</strong></p><p>A scalar representing the trace of ρ.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">t = get_trace(ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L50-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace_moment" href="#RandomMeas.get_trace_moment"><code>RandomMeas.get_trace_moment</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace_moment(ψ::Union{MPS, MPO}, k::Int, subsystem::Vector{Int}=collect(1:length(ψ)))</code></pre><p>Compute the kth trace moment of the reduced density matrix for a given subsystem of a quantum state.</p><p>For a pure state (MPS) and when the subsystem is contiguous starting from site 1, the function computes the entanglement spectrum of the bipartition defined by the last site in <code>subsystem</code> and returns the kth moment of the squared Schmidt coefficients. Otherwise, the function reduces the state to the specified subsystem.</p><p>For k = 2 (purity), it returns the squared norm (which is equivalent to tr(ρ²)). For k &gt; 2, it computes ρ^k via repeated application of the <code>apply</code> function (with a cutoff) and returns the trace of the resulting tensor.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::Union{MPS, MPO}</code>: The quantum state, represented as an MPS (for pure states) or MPO (for mixed states).</li><li><code>k::Int</code>: The moment order to compute (must be an integer ≥ 1).</li><li><code>subsystem::Vector{Int}</code> (optional): A vector of site indices (1-based) specifying the subsystem to retain. Defaults to all sites.</li></ul><p><strong>Returns</strong></p><p>A scalar (Float64) representing the kth trace moment of the reduced density matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">moment = get_trace_moment(ψ, 3, [1, 2, 3]; partial_transpose=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L297-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace_moment-Tuple{ITensor, Int64}" href="#RandomMeas.get_trace_moment-Tuple{ITensor, Int64}"><code>RandomMeas.get_trace_moment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace_moment(spec::ITensor, k::Int)</code></pre><p>Compute the kth moment of the entanglement spectrum represented by the ITensor <code>spec</code>.</p><p>The function assumes that <code>spec</code> is a square ITensor whose diagonal elements correspond to the singular values (Schmidt coefficients) of a reduced density matrix. The kth moment is computed as:</p><pre><code class="nohighlight hljs">pk = ∑ₗ (spec[l, l]^(2*k))</code></pre><p>which effectively computes the sum over the kth powers of the squared singular values.</p><p><strong>Arguments</strong></p><ul><li><code>spec::ITensor</code>: A square ITensor representing the entanglement spectrum.</li><li><code>k::Int</code>: The moment order to compute (must be an integer ≥ 1).</li></ul><p><strong>Returns</strong></p><p>A scalar (Float64) corresponding to the kth moment.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">moment = get_trace_moment(spec, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L264-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.get_trace_moments" href="#RandomMeas.get_trace_moments"><code>RandomMeas.get_trace_moments</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trace_moments(ψ::Union{MPS, MPO}, k_vector::Vector{Int}, subsystem::Vector{Int}=collect(1:length(ψ)))</code></pre><p>Compute a vector of trace moments for a quantum state <code>ψ</code> over a specified subsystem.</p><p>For each moment order <code>k</code> in <code>k_vector</code>, the function computes the kth trace moment of the reduced density matrix obtained by applying <code>reduce_to_subsystem(ψ, subsystem)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::Union{MPS, MPO}</code>: The quantum state, represented as an MPS (for pure states) or an MPO (for mixed states).</li><li><code>k_vector::Vector{Int}</code>: A vector of integer moment orders (each ≥ 1) for which the trace moments are computed.</li><li><code>subsystem::Vector{Int}</code> (optional): A vector of site indices (1-based) specifying the subsystem to consider. Defaults to all sites.</li></ul><p><strong>Returns</strong></p><p>A vector of scalars, each being the kth trace moment corresponding to the entries of <code>k_vector</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">moments = get_trace_moments(ψ, [1, 2, 3], [1, 2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L344-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.partial_transpose-Tuple{MPO, Vector{Int64}}" href="#RandomMeas.partial_transpose-Tuple{MPO, Vector{Int64}}"><code>RandomMeas.partial_transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_transpose(ρ::MPO, subsystem::Vector{Int})</code></pre><p>Compute the partial transpose of an MPO over the sites specified by <code>subsystem</code>.</p><p>For each site index in the MPO:</p><ul><li>If the index is in the <code>subsystem</code>, the tensor is transposed by swapping its unprimed and primed indices using <code>swapind</code>.</li><li>Otherwise, the tensor is left unchanged (multiplied by 1.0 for type consistency).</li></ul><p><strong>Arguments</strong></p><ul><li><code>ρ::MPO</code>: A Matrix Product Operator representing a density matrix.</li><li><code>subsystem::Vector{Int}</code>: A vector of site indices (1-based) over which to apply the transpose.</li></ul><p><strong>Returns</strong></p><p>An MPO in which the tensors corresponding to the sites in <code>subsystem</code> have been partially transposed.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ρT = partial_transpose(ρ, [2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L194-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.reduce_to_subsystem-Tuple{MPO, Vector{Int64}}" href="#RandomMeas.reduce_to_subsystem-Tuple{MPO, Vector{Int64}}"><code>RandomMeas.reduce_to_subsystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_to_subsystem(ρ::MPO, subsystem::Vector{Int64})</code></pre><p>Compute the reduced density matrix (as an MPO) for a specified subsystem.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::MPO</code>: A Matrix Product Operator representing the full density matrix.</li><li><code>subsystem::Vector{Int64}</code>: A vector of site indices (1-based) specifying the subsystem to retain.</li></ul><p><strong>Returns</strong></p><p>An MPO representing the reduced density matrix over the sites specified in <code>subsystem</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ρ_reduced = reduce_to_subsystem(ρ, [2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L112-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RandomMeas.reduce_to_subsystem-Tuple{MPS, Vector{Int64}}" href="#RandomMeas.reduce_to_subsystem-Tuple{MPS, Vector{Int64}}"><code>RandomMeas.reduce_to_subsystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_to_subsystem(ψ::MPS, subsystem::Vector{Int64})</code></pre><p>Compute the reduced density matrix for a pure state represented by the MPS <code>ψ</code> over the specified subsystem.</p><p>This function first constructs the density matrix by taking the outer product of <code>ψ</code> with itself, and then applies the MPO version of <code>reduce_to_subsystem</code> to obtain the reduced density matrix for the sites specified in <code>subsystem</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ::MPS</code>: A Matrix Product State representing a pure quantum state.</li><li><code>subsystem::Vector{Int64}</code>: A vector of site indices (1-based) specifying the subsystem to retain.</li></ul><p><strong>Returns</strong></p><p>An MPO representing the reduced density matrix over the specified subsystem.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ρ_sub = reduce_to_subsystem(ψ, [2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvermersch/RandomMeas.jl/blob/62a0f754033b9c338018c42f3abe7197073da456/src/TensorNetworkUtilities.jl#L169-L189">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Classical-shadows"><a class="docs-heading-anchor" href="#Classical-shadows">Classical shadows</a><a id="Classical-shadows-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-shadows" title="Permalink"></a></h3><ol><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/EnergyVarianceMeasurements.ipynb">Energy/Energy variance measurements with classical shadows</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/RobustShadowTomography.ipynb">Robust Shadow tomography</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/ProcessShadowTomography.ipynb">Process Shadow tomography</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/ShallowShadows.ipynb">Classical shadows with shallow circuits</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/VirtualDistillation.ipynb">Virtual distillation</a></p></li></ol><h3 id="Quantum-benchmark"><a class="docs-heading-anchor" href="#Quantum-benchmark">Quantum benchmark</a><a id="Quantum-benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-benchmark" title="Permalink"></a></h3><ol><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/CrossEntropyBenchmarking.ipynb">Cross-Entropy/Self-Cross entropy benchmarking</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/FidelityCommonRandomizedMeasurements.ipynb">Fidelities from common randomized measurements</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/CrossPlatform.ipynb">Cross-Platform verification</a></p></li></ol><h3 id="Entanglement"><a class="docs-heading-anchor" href="#Entanglement">Entanglement</a><a id="Entanglement-1"></a><a class="docs-heading-anchor-permalink" href="#Entanglement" title="Permalink"></a></h3><ol><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/PureStateEntanglement.ipynb">Entanglement entropy of pure states&quot;</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/BrydgesScience2019.ipynb">Analyzing the experimental data of Brydges et al, Science 2019</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/EntanglementSurfaceCode.ipynb">Surface code and the measurement of the topological entanglement entropy</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/MixedStateEntanglement.ipynb">Mixed-state entanglement: The p3-PPT condition and batch shadows</a></p></li></ol><h3 id="Miscellanous"><a class="docs-heading-anchor" href="#Miscellanous">Miscellanous</a><a id="Miscellanous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellanous" title="Permalink"></a></h3><ol><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/CircuitNoiseSimulations.ipynb">Noisy circuit simulations with tensor networks</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/ErrorBars.ipynb">Estimating statistical error bars via Jackknife resampling</a></p></li><li><p><a href="https://github.com/bvermersch/RandomMeas.jl/blob/main/examples/RandomizedMeasurementsQiskit.ipynb">Executing randomized measurements on IBM&#39;s quantum computers</a></p></li></ol></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Friday 14 March 2025 21:19">Friday 14 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
