var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = RandomMeas","category":"page"},{"location":"#RandomMeas","page":"Home","title":"RandomMeas","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RandomMeas.jl: The randomized measurement toolbox in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depth = 2:3","category":"page"},{"location":"#Data-acquisition","page":"Home","title":"Data acquisition","text":"","category":"section"},{"location":"#Data-acquisition-types","page":"Home","title":"Data acquisition types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RandomMeas]\nPages = [\"MeasurementStructures.jl\"]","category":"page"},{"location":"#RandomMeas.AbstractMeasurementSetting","page":"Home","title":"RandomMeas.AbstractMeasurementSetting","text":"AbstractMeasurementSetting\n\nAn abstract type representing a general measurement setting. Concrete implementations (e.g. LocalUnitaryMeasurementSetting, ComputationalBasisMeasurementSetting) should subtype this.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ComputationalBasisMeasurementSetting","page":"Home","title":"RandomMeas.ComputationalBasisMeasurementSetting","text":"ComputationalBasisMeasurementSetting\n\nA struct representing computational basis measurement settings for quantum systems. This setting uses the computational basis, so that each local unitary is by construction simply the identity operator.\n\nFields\n\nN::Int: Number of sites (qubits).\nlocal_unitary::Vector{ITensor}: A vector of N identity ITensors.\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nConstraints\n\nN == length(site_indices).\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ComputationalBasisMeasurementSetting-Tuple{ComputationalBasisMeasurementSetting}","page":"Home","title":"RandomMeas.ComputationalBasisMeasurementSetting","text":"ComputationalBasisMeasurementSetting(ms::ComputationalBasisMeasurementSetting;\n                                    N=ms.N,\n                                    local_unitary=ms.local_unitary,\n                                    site_indices=ms.site_indices)\n\nMake a new ComputationalBasisMeasurementSetting by copying fields from ms, but overriding any that you pass by keyword.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.LocalMeasurementSetting","page":"Home","title":"RandomMeas.LocalMeasurementSetting","text":"LocalMeasurementSetting\n\nAn abstract type for measurement settings that correspond to local (i.e. single qubit/site) measurements.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.LocalUnitaryMeasurementSetting","page":"Home","title":"RandomMeas.LocalUnitaryMeasurementSetting","text":"LocalUnitaryMeasurementSetting(N, local_unitary, site_indices)\n\nA measurement setting where each qubit is specified by a single-qubit rotation. Rotates from the computational basis into the measurement basis.\n\nFields\n\nN::Int: Number of sites (qubits).\nlocal_unitary::Vector{ITensor}: A vector of N ITensors representing the local unitary basis rotations.\nsite_indices::Vector{Index{Int64}}: A vector of site indices of length N.\n\nConstraints\n\nN == length(local_unitary) == length(site_indices).\nEach ITensor in local_unitary has exactly two indices:\nOne unprimed (site_indices[i])\nOne primed (prime(site_indices[i])).\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.LocalUnitaryMeasurementSetting-Tuple{LocalUnitaryMeasurementSetting}","page":"Home","title":"RandomMeas.LocalUnitaryMeasurementSetting","text":"LocalUnitaryMeasurementSetting(ms::LocalUnitaryMeasurementSetting;\n                                N=ms.N,\n                                local_unitary=ms.local_unitary,\n                                site_indices=ms.site_indices)\n\nMake a new LocalUnitaryMeasurementSetting by copying fields from ms, but overriding any that you pass by keyword.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementData","page":"Home","title":"RandomMeas.MeasurementData","text":"MeasurementData{T}\n\nA container for measurement data and settings obtained in actual or simulated quantum experiments.\n\nFields\n\nN::Int: Number of sites (qubits).\nNM::Int: Number of measurements per setting.\nmeasurement_results::Array{Int, 2}: A 2D array of binary measurement results with dimensions (NM, N).\nmeasurement_setting::T: A measurement setting of type T (subtype of AbstractMeasurementSetting) or nothing.\n\nType Parameter\n\nT: The type of the measurement setting, constrained to Union{Nothing, AbstractMeasurementSetting}.\n\nUsage\n\nTypically constructed via the provided constructors.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.MeasurementGroup","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup{T}\n\nA container for a group of measurement data objects used in actual or simulated quantum experiments.\n\nFields\n\nN::Int: Number of sites (qubits).\nNU::Int: Number of measurement data objects.\nNM::Int: Number of measurements per setting.\nmeasurements::Vector{MeasurementData{T}}: A vector of measurement data objects.\n\nType Parameter\n\nT: The type of the measurement setting for each measurement data object, constrained to Union{Nothing, AbstractMeasurementSetting}.\n\nUsage\n\nTypically constructed via one of the provided constructors.\n\nExample\n\n# Assume setting1 and setting2 are valid measurement settings\ndata1 = MeasurementData(results1; measurement_setting=setting1)\ndata2 = MeasurementData(results2; measurement_setting=setting2)\ngroup = MeasurementGroup([data1, data2])\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.MeasurementProbability","page":"Home","title":"RandomMeas.MeasurementProbability","text":"MeasurementProbability{T}\n\nA container for measurement probabilities and settings obtained either estimated from measurement data or directly computed from quantum states.\n\nFields\n\nN::Int: Number of sites (qubits).\nmeasurement_probability::ITensor: An ITensor representing Born probability.\nmeasurement_setting::T: A measurement setting of type T or nothing.\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nType Parameter\n\nT: The type of measurement setting, constrained to Union{Nothing, AbstractMeasurementSetting}.\n\nUsage\n\nConstructed either from measurement data or directly from quantum states.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ShallowUnitaryMeasurementSetting","page":"Home","title":"RandomMeas.ShallowUnitaryMeasurementSetting","text":"ShallowUnitaryMeasurementSetting\n\nA struct representing measurement settings which is, for each qubit, specified through a single qubit rotation, rotating from the computational basis into the measurement basis.\n\nFields\n\nN::Int: Number of sites (qubits).\n'K::Int`: Number of gates that creates the shallow_unitary\nlocalunitary::Vector{ITensor}: A vector of Ngates representing the shallow unitary\nsite_indices::Vector{Index{Int64}}: A vector of site indices of length N.\n\nConstructor\n\nCreates a ShallowUnitaryMeasurementSetting object after validating that:\n\nThe length of local_unitary equals K\nThe length of site_indices equals N.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ShallowUnitaryMeasurementSetting-Tuple{ShallowUnitaryMeasurementSetting}","page":"Home","title":"RandomMeas.ShallowUnitaryMeasurementSetting","text":"ShallowUnitaryMeasurementSetting(ms::ShallowUnitaryMeasurementSetting;\n                                N=ms.N,\n                                K=ms.K,\n                                local_unitary=ms.local_unitary,\n                                site_indices=ms.site_indices)\n\nMake a new ShallowUnitaryMeasurementSetting by copying fields from ms, but overriding any that you pass by keyword.\n\n\n\n\n\n","category":"method"},{"location":"#Data-acquisition-routines","page":"Home","title":"Data acquisition routines","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RandomMeas]\nPages = [\"MeasurementSetting.jl\",\"MeasurementData.jl\",\"MeasurementGroup.jl\",\"MeasurementProbability.jl\"]","category":"page"},{"location":"#RandomMeas.ComputationalBasisMeasurementSetting-Tuple{Int64}","page":"Home","title":"RandomMeas.ComputationalBasisMeasurementSetting","text":"ComputationalBasisMeasurementSetting(N; site_indices=nothing)\n\nCreate a ComputationalBasisMeasurementSetting for N sites. This setting corresponds to measurement in the computational basis.\n\nArguments:\n\nN::Int: Number of sites (qubits).\nsite_indices::Union{Vector{Index{Int64}}, Nothing} (optional): Site indices. If nothing, they are automatically generated.\n\nReturns:\n\nA ComputationalBasisMeasurementSetting object.\n\nExample:\n\nsetting = ComputationalBasisMeasurementSetting(4)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.LocalUnitaryMeasurementSetting-Tuple{Array{ComplexF64, 3}}","page":"Home","title":"RandomMeas.LocalUnitaryMeasurementSetting","text":"LocalUnitaryMeasurementSetting(local_unitary_array; site_indices=nothing)\n\nCreate a LocalUnitaryMeasurementSetting object from an N × 2 × 2 array of unitary matrices.\n\nArguments:\n\nlocal_unitary_array::Array{ComplexF64, 3}: An N × 2 × 2 array of unitary matrices.\nsite_indices::Union{Vector{Index{Int64}}, Nothing} (optional): Site indices. If nothing, they are automatically generated.\n\nReturns:\n\nA LocalUnitaryMeasurementSetting object.\n\nExample:\n\nunitary_array = rand(ComplexF64, 4, 2, 2)\nsetting = LocalUnitaryMeasurementSetting(unitary_array)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.LocalUnitaryMeasurementSetting-Tuple{Int64}","page":"Home","title":"RandomMeas.LocalUnitaryMeasurementSetting","text":"LocalUnitaryMeasurementSetting(N; site_indices=nothing, ensemble=\"Haar\")\n\nCreate a LocalUnitaryMeasurementSetting object by randomly sampling local unitary operators.\n\nArguments:\n\nN::Int: Number of sites (qubits).\nsite_indices::Union{Vector{Index}, Nothing} (optional): Site indices. If nothing, they are automatically generated.\nensemble::String: Type of random unitary (\"Haar\", \"Pauli\", \"Identity\").\n\nReturns:\n\nA LocalUnitaryMeasurementSetting object.\n\nExample:\n\nsetting = LocalUnitaryMeasurementSetting(4, ensemble=\"Haar\")\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.ShallowUnitaryMeasurementSetting-Tuple{Int64, Int64}","page":"Home","title":"RandomMeas.ShallowUnitaryMeasurementSetting","text":"ShallowUnitaryMeasurementSetting(N, depth; site_indices=nothing)\n\nCreate a ShallowUnitaryMeasurementSetting object by generating a random quantum circuit.\n\nArguments:\n\nN::Int: Number of sites (qubits).\ndepth::Int: Depth of the random circuit.\nsite_indices::Union{Vector{Index{Int64}}, Nothing} (optional): Site indices. If nothing, they are automatically generated.\n\nReturns:\n\nA ShallowUnitaryMeasurementSetting object.\n\nExample:\n\nsetting = ShallowUnitaryMeasurementSetting(4, 3)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.export_LocalUnitaryMeasurementSetting-Tuple{LocalUnitaryMeasurementSetting, String}","page":"Home","title":"RandomMeas.export_LocalUnitaryMeasurementSetting","text":"Export the unitary in a LocalUnitaryMeasurementSetting object to an .npz file with a single field: local_unitary.\n\nArguments:\n\nms::LocalUnitaryMeasurementSetting: The measurement settings to export.\nfilepath::String: Path to the output .npz file.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_rotation","page":"Home","title":"RandomMeas.get_rotation","text":"get_rotation(site_index, ensemble=\"Haar\")\n\nGenerate a single-qubit unitary sampled from a specified ensemble.\n\nArguments:\n\nsite_index::Index{Int64}: Site index.\nensemble::String: Type of unitary ensemble (\"Haar\", \"Pauli\", \"Identity\").\n\nReturns:\n\nAn ITensor representing the unitary transformation.\n\nExample:\n\nU = get_rotation(site_index, \"Pauli\")\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.import_LocalUnitaryMeasurementSetting-Tuple{String}","page":"Home","title":"RandomMeas.import_LocalUnitaryMeasurementSetting","text":"Import unitary from an .npz file and create a LocalUnitaryMeasurementSetting object.\n\nArguments:\n\nfilepath::String: Path to the input .npz file.\nsite_indices::Union{Vector{Index{Int64}}, Nothing}: Optional site indices. If not provided, they will be generated.\n\nReturns:\n\nA LocalUnitaryMeasurementSettings object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.reduce_to_subsystem-Tuple{LocalMeasurementSetting, Vector{Int64}}","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(settings, subsystem)\n\nReduce a LocalMeasurementSetting object to a specified subsystem.\n\nArguments:\n\nsettings::LocalMeasurementSetting: The original measurement settings object.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns:\n\nA new LocalMeasurementSetting object corresponding to the specified subsystem.\n\nExample:\n\nreduced_setting = reduce_to_subsystem(full_setting, [1, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementData-Tuple{Union{MPO, MPS}, Int64, Union{ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting, ShallowUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.MeasurementData","text":"MeasurementData(ψ::Union{MPO, MPS}, NM::Int; mode::String = \"MPS/MPO\", measurement_setting::Union{LocalUnitaryMeasurementSetting, ComputationalBasisMeasurementSetting, ShallowUnitaryMeasurementSetting} = nothing)\n\nReturns a MeasurementData object by sampling NM projective measurements from the quantum state ψ.\n\nArguments\n\nψ::Union{MPO, MPS}: The quantum state represented as a Matrix Product Operator (MPO) or Matrix Product State (MPS).\nNM::Int: The number of measurement shots to simulate for each setting.\nmode::String (optional): Specifies the simulation method. Options:\n\"dense\": Uses the dense representation.\n\"MPS/MPO\" (default): Uses tensor network methods for memory efficiency.\nmeasurement_setting (optional): A measurement setting object (if not provided, defaults to computational basis measurements).\n\nReturns\n\nA MeasurementData object with the corresponding measurement results and setting.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementData-Union{Tuple{Matrix{Int64}}, Tuple{T}} where T<:Union{Nothing, RandomMeas.AbstractMeasurementSetting}","page":"Home","title":"RandomMeas.MeasurementData","text":"MeasurementData(measurement_results::Array{Int, 2}; measurement_setting::Union{T, Nothing} = nothing)\n\nCreates a MeasurementData object by inferring the dimensions of the measurement results and validating the provided setting.\n\nArguments\n\nmeasurement_results::Array{Int, 2}: A 2D array of binary measurement results with shape (NM, N).\nmeasurement_setting::Union{T <: AbstractMeasurementSetting, Nothing} (optional): Measurement setting or nothing if not provided.\n\nReturns\n\nA MeasurementData object with inferred dimensions and validated setting.\n\nThrows\n\nAssertionError: If the dimensions of measurement_results and measurement_setting are inconsistent.\n\nExamples\n\n# With measurement setting\nsetting = LocalUnitaryMeasurementSetting(4, ensemble=\"Haar\")\nresults = rand(1:2, 10, 4)\ndata_with_setting = MeasurementData(results; measurement_setting=setting)\n\n# Without measurement setting\ndata_without_setting = MeasurementData(rand(1:2, 10, 4))\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementData-Union{Tuple{T}, Tuple{MeasurementProbability{T}, Int64}} where T<:Union{Nothing, RandomMeas.AbstractMeasurementSetting}","page":"Home","title":"RandomMeas.MeasurementData","text":"MeasurementData(measurement_probability::MeasurementProbability{T}, NM::Int) where T <: Union{Nothing, AbstractMeasurementSetting}\n\nReturns a MeasurementData object by sampling NM projective measurements based on the provided measurement probability.\n\nArguments\n\nmeasurement_probability::MeasurementProbability: A container with the measurement probability (an ITensor) and associated settings.\nNM::Int: The number of projective measurements to sample.\n\nReturns\n\nA MeasurementData object with dimensions inferred from the measurement probability.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.export_MeasurementData-Union{Tuple{T}, Tuple{MeasurementData{T}, String}} where T<:Union{Nothing, ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting}","page":"Home","title":"RandomMeas.export_MeasurementData","text":"export_measurement_data(data::MeasurementData, filepath::String)\n\nExports measurement data to a .npz file.\n\nArguments\n\ndata::MeasurementData: The measurement data object containing measurement results and optionally a LocalUnitaryMeasurementSetting setting.\nfilepath::String: The file path where the data will be exported.\n\nDetails\n\nThe measurement_results are exported directly as they are.\nIf measurement_setting is provided, the associated local_unitaries are extracted, reshaped, and included in the export.\n\nNotes\n\nThe exported .npz file will contain:\n\"measurement_results\": A 2D array of shape (NM, N), where:\nNM: Number of measurements per setting.\nN: Number of qubits/sites.\n\"local_unitaries\" (optional): A 4D array of shape (N, 2, 2) representing the unitary transformations for each site.\n\nExample\n\n\n# Create MeasurementData object\ndata = MeasurementData(measurement_results; measurement_setting=measurement_setting)\n\n# Export to a file\nexport_measurement_data(data, \"exported_data.npz\")\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.import_MeasurementData-Tuple{String}","page":"Home","title":"RandomMeas.import_MeasurementData","text":"import_measurement_data(filepath::String; predefined_setting=nothing, site_indices=nothing)\n\nImports measurement results and optional measurement settings from an archive file.\n\nArguments\n\nfilepath::String: Path to the .npz file containing the measurement results and optionally local unitaries. The file should contain at least a field measurement_results (2D binary array of shape (NM, N)), and optionally a field local_unitaries (local unitaries as a Nx2x2 array).\npredefined_setting (optional): A predefined MeasurementSetting object. If provided, this will be used instead of the file's setting.\nsite_indices (optional): A vector of site indices to be used when constructing LocalUnitaryMeasurementSetting from the field local_unitaries (only relevant if predefined_setting is not provided). If not provided, the default site indices will be generated internally.\n\nReturns\n\nA MeasurementData object containing the imported results and settings.\n\nExamples\n\n# Import with predefined settings\nsetting = LocalUnitaryMeasurementSetting(local_unitaries; site_indices=siteinds(\"Qubit\", 5))\ndata_with_setting = import_measurement_data(\"data.npz\"; predefined_setting=setting)\n\n# Import with site indices provided\ndata_with_indices = import_measurement_data(\"data.npz\"; site_indices=siteinds(\"Qubit\", 5))\n\n# Import without any additional options\ndata = import_measurement_data(\"data.npz\")\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.reduce_to_subsystem-Union{Tuple{T}, Tuple{MeasurementData{T}, Vector{Int64}}} where T<:Union{Nothing, LocalMeasurementSetting}","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(data::MeasurementData{T}, subsystem::Vector{Int}) where T <: Union{Nothing, LocalMeasurementSetting}\n\nReduce a MeasurementData object to a specified subsystem, preserving the measurement setting type if available.\n\nArguments\n\ndata::MeasurementData{T}: The original measurement data object, where T is either nothing or a subtype of LocalMeasurementSetting.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain. Each index must be between 1 and data.N.\n\nReturns\n\nA new MeasurementData{T} object with:\n\nThe measurement results reduced from dimensions (NM, N) to (NM, |subsystem|).\nThe measurement setting reduced accordingly (if one is provided), or remaining as nothing.\n\nExample\n\n# Suppose `data` is a MeasurementData object with N = 4.\n# To retain only sites 1 and 3:\nreduced_data = reduce_to_subsystem(data, [1, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementGroup-Tuple{Union{MPO, MPS}, Int64, Int64, Int64}","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup(ψ::Union{MPO, MPS}, NU::Int, NM::Int, depth::Int; mode::String = “MPS/MPO”, progress_bar::Bool=false)\n\n::MeasurementGroup{ShallowUnitaryMeasurementSetting}\n\nConstruct a MeasurementGroup from a quantum state ψ by generating NU shallow measurement settings and simulating NM measurements per unitary.\n\nArguments\n\nψ::Union{MPO, MPS}: The quantum state.\nNU::Int: Number of measurement data objects to generate.\nNM::Int: Number of measurements per setting.\ndepth::Int: Circuit depth for shallow settings.\nmode::String: Simulation mode; defaults to “MPS/MPO”.\nprogress_bar::Bool: Whether to show a progress bar.\n\nReturns\n\nA MeasurementGroup{ShallowUnitaryMeasurementSetting} object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementGroup-Tuple{Union{MPO, MPS}, Int64, Int64}","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup(ψ::Union{MPO, MPS}, NU::Int, NM::Int; mode::String = “MPS/MPO”, progress_bar::Bool=false)\n\n::MeasurementGroup{LocalUnitaryMeasurementSetting}\n\nConstruct a MeasurementGroup from a quantum state ψ by generating NU local measurement settings and simulating NM projective measurements per setting.\n\nArguments\n\nψ::Union{MPO, MPS}: The quantum state.\nNU::Int: Number of measurement data objects to generate.\nNM::Int: Number of measurements per setting.\nmode::String: Simulation mode; defaults to “MPS/MPO”.\nprogress_bar::Bool: Whether to show a progress bar.\n\nReturns\n\nA MeasurementGroup{LocalUnitaryMeasurementSetting} object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementGroup-Union{Tuple{Array{MeasurementData{T}, 1}}, Tuple{T}} where T<:Union{Nothing, RandomMeas.AbstractMeasurementSetting}","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup(measurements::Vector{MeasurementData{T}}) where {T <: Union{Nothing, AbstractMeasurementSetting}}\n\nConstruct a MeasurementGroup object by inferring dimensions from a vector of MeasurementData objects.\n\nArguments\n\nmeasurements::Vector{MeasurementData{T}}: A vector of MeasurementData objects.\n\nReturns\n\nA MeasurementGroup object with:\n\nN: Inferred from the first element (assumed consistent across all elements).\nNU: Number of measurement data objects.\nNM: Inferred from the first element.\nmeasurements: The provided vector.\n\nExample\n\nsetting1 = LocalUnitaryMeasurementSetting(4, ensemble=\"Haar\")\nresults1 = rand(1:2, 10, 4)\ndata1 = MeasurementData(results1; measurement_setting=setting1)\nsetting2 = LocalUnitaryMeasurementSetting(4, ensemble=\"Haar\")\nresults2 = rand(1:2, 10, 4)\ndata2 = MeasurementData(results2; measurement_setting=setting2)\ngroup = MeasurementGroup([data1, data2])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementGroup-Union{Tuple{T}, Tuple{Union{MPO, MPS}, Vector{T}, Int64}} where T<:RandomMeas.AbstractMeasurementSetting","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup(ψ::Union{MPO, MPS}, measurement_settings::Vector{AbstractMeasurementSetting}, NM::Int; mode::String = “MPS/MPO”, progress_bar::Bool=false)\n::MeasurementGroup{T} where T <: AbstractMeasurementSetting\n\nConstruct a MeasurementGroup from a quantum state ψ by generating NU local measurement settings and simulating NM projective measurements per setting.\n\nArguments\n\nψ::Union{MPO, MPS}: The quantum state.\nmeasurement_settings::Vector{AbstractMeasurementSetting}: A vector with measurement settings\nNM::Int: Number of measurements per setting.\nmode::String: Simulation mode; defaults to “MPS/MPO”.\nprogress_bar::Bool: Whether to show a progress bar.\n\nReturns\n\nA MeasurementGroup{T} object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.export_MeasurementGroup-Union{Tuple{T}, Tuple{MeasurementGroup{T}, String}} where T<:Union{Nothing, ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting}","page":"Home","title":"RandomMeas.export_MeasurementGroup","text":"export_MeasurementGroup(group::MeasurementGroup{T}, filepath::String)\n\nExport a MeasurementGroup object to an NPZ file.\n\nArguments\n\ngroup::MeasurementGroup{T}: A MeasurementGroup object where each MeasurementData may have its own measurement setting of type T (with T <: Union{Nothing, LocalUnitaryMeasurementSetting, ComputationalBasisMeasurementSetting}).\nfilepath::String: The file path where the NPZ file will be written.\n\nDetails\n\nThe measurement results from each MeasurementData object (each of shape (NM, N)) are stacked into a 3D array of shape (NU, NM, N), where NU is the number of MeasurementData objects.\nThe measurement settings are exported as a Complex array of size NU x N x 2 x 2 if present.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.import_MeasurementGroup-Tuple{String}","page":"Home","title":"RandomMeas.import_MeasurementGroup","text":"import_MeasurementGroup(filepath::String; predefined_settings=nothing, site_indices=nothing) -> MeasurementGroup\n\nImport a MeasurementGroup object from an NPZ file.\n\nArguments\n\nfilepath::String: The path to the NPZ file containing the exported MeasurementGroup data.\npredefined_settings (optional): A vector of predefined measurement settings (one per MeasurementData object). If provided, its length must equal the exported NU.\nsite_indices (optional): A vector of N site indices to use when reconstructing the measurement setting. If not provided, default site indices are generated using siteinds(\"Qubit\", N).\n\nReturns\n\nA MeasurementGroup object with:\n\nMeasurement results reconstructed from a 3D array of shape (NU, NM, N).\nA measurement setting for each MeasurementData object reconstructed from a 4D array of shape (NU, N, 2, 2) if present, or taken from predefined_settings if provided.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.reduce_to_subsystem-Union{Tuple{T}, Tuple{MeasurementGroup{T}, Vector{Int64}}} where T<:Union{Nothing, LocalMeasurementSetting}","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(\ngroup::MeasurementGroup{T},\nsubsystem::Vector{Int}\n\n)::MeasurementGroup{T} where T <: LocalMeasurementSetting\n\nReduce a MeasurementGroup object (withLocalUnitaryMeasurementSetting`) to a specified subsystem.\n\nArguments\n\ngroup::MeasurementGroup{LocalUnitaryMeasurementSetting}: The original measurement data object.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns\n\nA new MeasurementGroup object corresponding to the specified subsystem.\n\n\n\n\n\n","category":"method"},{"location":"#Postprocessing-(excluding-classical-shadows)","page":"Home","title":"Postprocessing (excluding classical shadows)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RandomMeas]\nPages = [\"Estimators.jl\"]","category":"page"},{"location":"#RandomMeas.get_XEB-Tuple{MPS, MeasurementData}","page":"Home","title":"RandomMeas.get_XEB","text":"get_XEB(ψ::MPS, measurement_data::MeasurementData)\n\nReturn the linear cross-entropy for the measurement results in measurement_data, with respect to a theory state ψ.\n\nArguments:\n\nψ::MPS: The theoretical state to compare against.\nmeasurement_data::MeasurementData: The measurement data object containing results and settings.\n\nReturns:\n\nThe linear cross-entropy as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_fidelity","page":"Home","title":"RandomMeas.get_fidelity","text":"get_fidelity(\n    group_1::MeasurementGroup,\n    group_2::MeasurementGroup,\n    subsystem::Vector{Int} = collect(1:group_1.N)\n)\n\nCompute the fidelity of two quantum states Tr(ρ1 ρ2)/SROOT(Tr(ρ1^2),Tr(ρ2^2)) from measurement data by averaging the overlap of measurement results.\n\nArguments\n\ngroup_1::MeasurementGroup: Measurement data for the first state.\ngroup_2::MeasurementGroup: Measurement data for the second state.\nsubsystem::Vector{Int} (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.\n\nReturns\n\nThe computed fidelity.\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.get_h_tensor","page":"Home","title":"RandomMeas.get_h_tensor","text":"get_h_tensor(s::Index, s_prime::Index) -> ITensor\n\nConstruct the Hamming tensor for given indices.\n\nArguments\n\ns::Index: Unprimed site index.\ns_prime::Index: Primed site index.\n\nReturns\n\nHamming_tensor::ITensor: The Hamming tensor connecting s and s_prime.\n\nMethod\n\nInitializes an ITensor with indices s and s_prime.\nAssigns values to represent the Hamming distance operation:\nDiagonal elements are set to 1.0.\nOff-diagonal elements are set to -0.5.\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.get_overlap","page":"Home","title":"RandomMeas.get_overlap","text":"get_overlap(\n    group_1::MeasurementGroup,\n    group_2::MeasurementGroup,\n    subsystem::Vector{Int} = collect(1:group_1.N);\n    apply_bias_correction::Bool = false\n)\n\nCompute the overlap of two quantum states from measurement data by averaging the overlap of measurement results.\n\nArguments\n\ngroup_1::MeasurementGroup: Measurement data for the first state.\ngroup_2::MeasurementGroup: Measurement data for the second state.\nsubsystem::Vector{Int} (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.\napply_bias_correction::Bool (optional): Whether to apply bias correction for the overlap. Defaults to false.\n\nReturns\n\nThe computed overlap (or purity if group_1 == group_2 and bias correction is applied).\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.get_overlap-Tuple{MeasurementData, MeasurementData}","page":"Home","title":"RandomMeas.get_overlap","text":"get_overlap(\n    data_1::MeasurementData,\n    data_2::MeasurementData\n)\n\nCompute the overlap between two quantum states for a single measurement setting.\n\nArguments\n\ndata_1::MeasurementData: Measurement Data for the first state, with dimensions (NM, N).\ndata_2::MeasurementData: Measurement Data for the second state, with dimensions (NM, N).\n\nReturns\n\nThe computed overlap for the single measurement setting.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_overlap-Tuple{MeasurementProbability, MeasurementProbability}","page":"Home","title":"RandomMeas.get_overlap","text":"get_overlap(prob1::MeasurementProbability, prob2::MeasurementProbability) -> Float64\n\nCompute the weighted overlap  \\2^N sum_s (-2)^{-D[s,s']}P(s)P(s')] by sequentially applying the Hamming tensor to each qubit index and contracting with the second probability tensor.\n\nArguments\n\nprob1::MeasurementProbability: The first Born probability tensor representing quantum state rho1.\nprob2::MeasurementProbability: The second Born probability tensor representing quantum state rho2.\n\nReturns\n\nweighted_overlap::Float64: The computed trace Tr(rho1 rho2) scaled appropriately..\n\nExample\n\nusing ITensors\n\n# Assume prob1 and prob2 are predefined MeasurementProbabilities\noverlap = get_overlap(prob1, prob2)\nprintln(\"Overlap: \", overlap)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_purity","page":"Home","title":"RandomMeas.get_purity","text":"get_purity(group::Measurementgroup, subsystem::Vector{Int} = collect(1:group.N))\n\nCompute the purity of a quantum state from measurement data by averaging the overlap of measurement results.\n\nArguments\n\ngroup::MeasurementGroup: Measurement data containing the results and settings of randomized measurements.\nsubsystem::Vector{Int} (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.\n\nReturns\n\nThe computed purity for the specified subsystem.\n\n\n\n\n\n","category":"function"},{"location":"#Postprocessing-for-classical-shadows","page":"Home","title":"Postprocessing for classical shadows","text":"","category":"section"},{"location":"#Classical-shadow-types","page":"Home","title":"Classical shadow types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RandomMeas]\nPages = [\"ShadowStructures.jl\"]","category":"page"},{"location":"#RandomMeas.AbstractShadow","page":"Home","title":"RandomMeas.AbstractShadow","text":"AbstractShadow\n\nAn abstract type representing a general classical shadow. Concrete subtypes should implement specific shadow methodologies, such as factorized or dense shadows.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.DenseShadow","page":"Home","title":"RandomMeas.DenseShadow","text":"DenseShadow\n\nA struct representing a dense classical shadow (a 2^N x 2^N matrix), stored as a single ITensor with 2N indices.\n\nFields\n\nshadow_data::ITensor: An ITensor with 2N indices representing the dense shadow.\nN::Int: Number of sites (qubits).\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nConstructor\n\nDenseShadow(shadow_data::ITensor, N::Int, site_indices::Vector{Index{Int64}}) validates that:\n\nsite_indices has length N.\nshadow_data has exactly 2N indices.\nThe set of unprimed indices in shadow_data matches site_indices.\nThe set of primed indices in shadow_data matches map(prime, site_indices).\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.FactorizedShadow","page":"Home","title":"RandomMeas.FactorizedShadow","text":"FactorizedShadow\n\nA struct representing a factorized classical shadow which can be represented as a tensor product of single qubit shadows.\n\nFields\n\nshadow_data::Vector{ITensor}: A vector of ITensors (each 2×2) representing the shadow for each qubit/site.\nN::Int: Number of qubits/sites.\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nConstructor\n\nFactorizedShadow(shadow_data::Vector{ITensor}, N::Int, site_indices::Vector{Index{Int64}}) validates that:\n\nThe length of shadow_data and site_indices equals N.\nEach ITensor in shadow_data has exactly two indices, which include the corresponding unprimed and primed site index.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ShallowShadow","page":"Home","title":"RandomMeas.ShallowShadow","text":"ShallowShadow\n\nA struct representing a shallow classical shadow, stored as a MPO ITensor object.\n\nFields\n\nshadow_data::MPOr: An MPO representing the shallow shadow.\nN::Int: Number of sites (qubits).\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nConstructor\n\nShallowShadow(shadow_data::MPO, N::Int, site_indices::Vector{Index{Int64}}) validates that:\n\nsite_indices has length N.\nshadow_data has exactly N Tensors, and the site indices match with site_indices\n\n\n\n\n\n","category":"type"},{"location":"#Classical-shadow-routines","page":"Home","title":"Classical shadow routines","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RandomMeas]\nPages = [\"AbstractShadows.jl\",\"FactorizedShadows.jl\", \"DenseShadows.jl\",\"ShallowShadows.jl\"]","category":"page"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, AbstractArray{<:AbstractShadow}}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadows::AbstractArray{<:AbstractShadow}; compute_sem::Bool = false)\n\nCompute the average expectation value of an MPO operator O using an array of shadow objects.\n\nArguments\n\nO::MPO: The MPO operator whose expectation value is to be computed.\nshadows::AbstractArray{<:AbstractShadow}: An array of shadow objects (of any shape) over which the expectation values are computed.\ncompute_sem::Bool (optional): If true, also compute the standard error of the mean (SEM). Default is false.\n\nReturns\n\nIf compute_sem is false, returns the average expectation value.\nIf compute_sem is true, returns a tuple (mean, sem), where mean is the average expectation value and sem is the standard error.\n\nExample\n\nmean_val = get_expect_shadow(O, shadows)\nmean_val, sem_val = get_expect_shadow(O, shadows; compute_sem=true)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, AbstractShadow}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadow::AbstractShadow)\n\nCompute the expectation value of an MPO operator O using a single shadow object.\n\nArguments:\n\nO::MPO: The MPO operator for which the expectation value is computed.\nshadow::AbstractShadow: A shadow object, either dense, factorized, or shallow.\n\nReturns\n\nThe expectation value as a scalar.\n\nExample\n\nval = get_expect_shadow(O, shadow)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moment-Tuple{Matrix{<:AbstractShadow}, Int64}","page":"Home","title":"RandomMeas.get_trace_moment","text":"get_trace_moment(shadows::Array{<:AbstractShadow, 2}, kth_moment::Int; O::Union{Nothing, MPO}=nothing)\n\nCompute a single trace moment from an array of AbstractShadow objects.\n\nArguments\n\nshadows::Array{<:AbstractShadow, 2}: An array of shadow objects with dimensions (n_ru, n_m), where n_ru is the number of random unitaries and n_m is the number of measurements.\nkth_moment::Int: The moment k to compute (e.g., k = 1, 2, ...).\nO::Union{Nothing, MPO} (optional): If provided, computes Tr[O * ρ^k]; otherwise, computes Tr[ρ^k] (default: nothing).\n\nReturns\n\nThe computed trace moment as a scalar.\n\nExample\n\nmoment1 = get_trace_moment(shadows, 1)\nmoment2 = get_trace_moment(shadows, 2; O=my_operator)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moment-Tuple{Vector{<:AbstractShadow}, Int64}","page":"Home","title":"RandomMeas.get_trace_moment","text":"get_trace_moment(shadows::Vector{<:AbstractShadow}, kth_moment::Int; O::Union{Nothing, MPO}=nothing)\n\nWrapper function. Compute a single trace moment for a vector of shadow objects by reshaping the vector into a 2D array.\n\nArguments\n\nshadows::Vector{<:AbstractShadow}: A vector of shadow objects.\nkth_moment::Int: The moment order k to compute.\nO::Union{Nothing, MPO} (optional): An MPO observable.\n\nReturns\n\nThe computed trace moment as a scalar.\n\nExample\n\nmoment = get_trace_moment(shadows_vector, 2; O=my_operator)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moments-Tuple{Matrix{<:AbstractShadow}, Vector{Int64}}","page":"Home","title":"RandomMeas.get_trace_moments","text":"get_trace_moments(shadows::Array{<:AbstractShadow, 2}, kth_moments::Vector{Int}; O::Union{Nothing, MPO}=nothing)\n\nWrapper function. Compute multiple trace moments from an array of shadow objects.\n\nArguments\n\nshadows::Array{<:AbstractShadow, 2}: An array of shadow objects with dimensions (n_ru, n_m).\nkth_moments::Vector{Int}: A vector of moment orders.\nO::Union{Nothing, MPO} (optional): An MPO observable; if provided, computes Tr[O * ρ^k] for each moment (default: nothing).\n\nReturns\n\nA vector of trace moments corresponding to each moment in kth_moments.\n\nExample\n\nmoments = get_trace_moments(shadows_array, [1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moments-Tuple{Vector{<:AbstractShadow}, Vector{Int64}}","page":"Home","title":"RandomMeas.get_trace_moments","text":"get_trace_moments(shadows::Vector{<:AbstractShadow}, kth_moments::Vector{Int}; O::Union{Nothing, MPO}=nothing)\n\nWrapper function. Compute multiple trace moments from a vector of shadow objects by reshaping the vector into a 2D array.\n\nArguments\n\nshadows::Vector{<:AbstractShadow}: A vector of shadow objects.\nkth_moments::Vector{Int}: A vector of moment orders.\nO::Union{Nothing, MPO} (optional): An MPO observable.\n\nReturns\n\nA vector of trace moments.\n\nExample\n\nmoments = get_trace_moments(shadows_vector, [1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_product-Tuple{Vararg{AbstractShadow}}","page":"Home","title":"RandomMeas.get_trace_product","text":"get_trace_product(shadows::AbstractShadow...; O::Union{Nothing, MPO}=nothing)\n\nCompute the product of multiple shadow objects and return its trace or expectation value.\n\nIf O is nothing, returns the trace of the product:     trace(shadow₁ * shadow₂ * ... * shadowₙ). If O is provided, returns the expectation value computed by:     getexpectshadow(O, shadow₁ * shadow₂ * ... * shadowₙ).\n\nArguments\n\nshadows...: A variable number of shadow objects.\nO::Union{Nothing, MPO} (optional): An MPO observable.\n\nReturns\n\nThe trace of the product if O is nothing, or the expectation value if O is provided.\n\nExample\n\nresult = get_trace_product(shadow1, shadow2, shadow3)\nresult_with_O = get_trace_product(shadow1, shadow2, shadow3; O=my_operator)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.multiply-Tuple{AbstractShadow, AbstractShadow}","page":"Home","title":"RandomMeas.multiply","text":"multiply(shadow1::AbstractShadow, shadow2::AbstractShadow)\n\nMultiply two shadow objects of the same concrete type.\n\nArguments:\n\nshadow1::AbstractShadow: The first shadow object.\nshadow2::AbstractShadow: The second shadow object.\n\nReturns\n\nA new shadow object representing the product.\n\nThrows\n\nAn ArgumentError if the types of shadow1 and shadow2 do not match.\n\nExample\n\nprod_shadow = multiply(shadow1, shadow2)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_trace-Tuple{AbstractArray{<:AbstractShadow}, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_trace","text":"partial_trace(shadows::AbstractArray{<:AbstractShadow}, subsystem::Vector{Int})\n\nCompute the partial trace for each shadow in a collection of shadows.\n\nArguments\n\nshadows::AbstractArray{<:AbstractShadow}: A collection of shadow objects (vector or 2D array).\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns\n\nAn array of shadows reduced to the specified subsystem, with the same dimensions as the input array.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_trace-Tuple{AbstractShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_trace","text":"partial_trace(shadow::AbstractShadow, subsystem::Vector{Int}; assume_unit_trace::Bool=false)\n\nCompute the partial trace of a shadow object over the complement of the specified subsystem.\n\nArguments\n\nshadow::AbstractShadow: The shadow object.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\nassume_unit_trace::Bool (optional): If true, assumes the shadow has unit trace (default: false).   This can speed up the calculation for factorized shadows (as the trace of \"traced out\" qubits is not computed)/\n\nReturns\n\nA new shadow object reduced to the specified subsystem.\n\nExample\n\nreduced_shadow = partial_trace(shadow, [1, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_transpose-Tuple{AbstractArray{<:AbstractShadow}, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(shadows::AbstractArray{<:AbstractShadow}, subsystem::Vector{Int})\n\nCompute the partial transpose for each shadow in a collection.\n\nArguments\n\nshadows::AbstractArray{<:AbstractShadow}: A collection (vector or 2D array) of shadow objects.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem(s) over which the transpose is to be performed.\n\nReturns\n\nAn array of shadow objects with the partial transpose applied, preserving the input dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_transpose-Tuple{AbstractShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(shadow::AbstractShadow, subsystem::Vector{Int})\n\nCompute the partial transpose of a shadow object over the specified subsystem(s). This operation is analogous to QuTiP's partial transpose method.\n\nArguments\n\nshadow::AbstractShadow: The shadow object for which the partial transpose is computed.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem(s) over which to perform the transpose.\n\nReturns\n\nA new shadow object that is the partial transpose of the input.\n\nExample\n\ntransposed_shadow = partial_transpose(shadow, [2, 4])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.trace-Tuple{AbstractArray{<:AbstractShadow}}","page":"Home","title":"RandomMeas.trace","text":"trace(shadows::AbstractArray{<:AbstractShadow})\n\nCompute the trace for each shadow in a collection of shadow objects.\n\nArguments:\n\nshadows::AbstractArray{<:AbstractShadow}: A collection (vector, matrix, etc.) of shadow objects.\n\nReturns\n\nAn array of scalar trace values corresponding to each shadow, with the same dimensions as the input.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.trace-Tuple{AbstractShadow}","page":"Home","title":"RandomMeas.trace","text":"trace(shadow::AbstractShadow)\n\nCompute the trace of a shadow object.\n\nArguments:\n\nshadow::AbstractShadow: A shadow object.\n\nReturns\n\nThe trace of the shadow object as a scalar.\n\nExample\n\nt = trace(shadow)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.FactorizedShadow-Tuple{Vector{Int64}, Vector{ITensor}}","page":"Home","title":"RandomMeas.FactorizedShadow","text":"FactorizedShadow(measurement_results::Vector{Int}, local_unitary::Vector{ITensor};\n                 G::Vector{Float64} = fill(1.0, length(local_unitary)))\n\nConstruct a FactorizedShadow object from raw measurement results and unitary transformations.\n\nArguments\n\nmeasurement_results::Vector{Int}: Vector of binary measurement results for each qubit/site.\nlocal_unitary::Vector{ITensor}: Vector of local unitary transformations applied during the measurement.\nG::Vector{Float64}(optional): Vector ofG` values for measurement error correction (default: 1.0 for all sites).\n\nReturns\n\nA FactorizedShadow object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.convert_to_dense_shadow-Tuple{FactorizedShadow}","page":"Home","title":"RandomMeas.convert_to_dense_shadow","text":"convert_to_dense_shadow(factorized_shadow::FactorizedShadow)\n\nConvert a FactorizedShadow object into a DenseShadow object.\n\nArguments\n\nfactorized_shadow::FactorizedShadow: The FactorizedShadow object to convert.\n\nReturns\n\nA DenseShadow object with the combined ITensor.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, FactorizedShadow}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadow::FactorizedShadow)\n\nCompute the expectation value of an MPO operator O using a factorized shadow.\n\nArguments:\n\nO::MPO: The MPO operator for which the expectation value is computed.\nshadow::FactorizedShadow: A factorized shadow object.\n\nReturns:\n\nThe expectation value as a ComplexF64 (or Float64 if purely real).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_factorized_shadows-Tuple{MeasurementData{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.get_factorized_shadows","text":"get_factorized_shadows(measurement_data::MeasurementData{LocalUnitaryMeasurementSetting};\n                       G::Vector{Float64} = fill(1.0, measurement_data.N))\n\nCompute factorized shadows for all measurement results in the provided MeasurementData.\n\nArguments\n\nmeasurement_data::MeasurementData{LocalUnitaryMeasurementSetting}: Measurement data object containing measurement results and settings.\nG::Vector{Float64} (optional): Vector of G values for measurement error correction (default: 1.0 for all sites).\n\nReturns\n\nA Vector of NM FactorizedShadow objects with dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_factorized_shadows-Tuple{MeasurementGroup{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.get_factorized_shadows","text":"get_factorized_shadows(measurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting};\n                       G::Vector{Float64} = fill(1.0, measurement_group.N))\n\nCompute factorized shadows for all measurement results in the provided MeasurementGroup.\n\nArguments\n\nmeasurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting}: Measurement data object containing measurement results and settings.\nG::Vector{Float64} (optional): Vector of G values for measurement error correction (default: 1.0 for all sites).\n\nReturns\n\nA Array of NU*NM FactorizedShadow objects with dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.multiply-Tuple{FactorizedShadow, FactorizedShadow}","page":"Home","title":"RandomMeas.multiply","text":"multiply(shadow1::FactorizedShadow, shadow2::FactorizedShadow)\n\nMultiply two FactorizedShadow objects element-wise.\n\nArguments\n\nshadow1::FactorizedShadow: The first FactorizedShadow object.\nshadow2::FactorizedShadow: The second FactorizedShadow object.\n\nReturns\n\nA new FactorizedShadow object representing the element-wise product of the two inputs.\n\nNotes\n\nBoth shadow1 and shadow2 must have the same number of qubits/sites.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_trace-Tuple{FactorizedShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_trace","text":"partial_trace(shadow::FactorizedShadow, subsystem::Vector{Int}; assume_unit_trace::Bool = false)\n\nCompute the partial trace of a FactorizedShadow object over the complement of the specified subsystem.\n\nArguments\n\nshadow::FactorizedShadow: The factorized shadow to compute the partial trace for.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\nassume_unit_trace::Bool (optional): If true, assumes all traced-out tensors have unit trace and skips explicit computation (default: false).\n\nReturns\n\nA new FactorizedShadow object reduced to the specified subsystem.\n\nNotes\n\nIf assume_unit_trace is true, avoids explicit trace computation for efficiency.\nIf assume_unit_trace is false, computes the traces of all tensors outside the subsystem and multiplies their product into the remaining tensors.\nIssues a warning if the trace product deviates significantly from 1 when assume_unit_trace is false.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_transpose-Tuple{FactorizedShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(shadow::FactorizedShadow, subsystem::Vector{Int})::FactorizedShadow\n\nCompute the partial transpose of a FactorizedShadow over the specified subsystem by swapping, for each site, the unprimed and primed indices using the swapind function. This function returns views of the underlying ITensors, avoiding unnecessary data duplication.\n\nArguments\n\nshadow::FactorizedShadow: The factorized classical shadow.\nsubsystem::Vector{Int}: A vector of 1-based site indices on which to perform the partial transpose.\n\nReturns\n\nA new FactorizedShadow with the specified sites partially transposed.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.trace-Tuple{FactorizedShadow}","page":"Home","title":"RandomMeas.trace","text":"trace(shadow::FactorizedShadow)\n\nCompute the trace of a FactorizedShadow object.\n\nArguments\n\nshadow::FactorizedShadow: The FactorizedShadow object whose trace is to be computed.\n\nReturns\n\nThe trace of the shadow as a Float64 or ComplexF64.\n\nNotes\n\nThe function computes the product of the traces of individual tensors in the factorized shadow.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.DenseShadow-Tuple{MeasurementData{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.DenseShadow","text":"DenseShadow(measurement_data::MeasurementData{LocalUnitaryMeasurementSetting}; G::Vector{Float64} = fill(1.0, size(measurement_data.N, 2)))\n\nConstruct a DenseShadow object from a MeasurementDataObject\n\nArguments\n\n`measurement_data::MeasurementData{LocalUnitaryMeasurementSetting}:\nG::Vector{Float64} (optional): Vector of G values to account for measurement errors (default: 1.0 for all sites).\n\nReturns\n\nA DenseShadow object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.DenseShadow-Tuple{MeasurementProbability{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.DenseShadow","text":"DenseShadow(measurement_probability::MeasurementProbability; G::Vector{Float64} = fill(1.0, length(u)))\n\nConstruct a DenseShadow object from a precomputed probability tensor.\n\nArguments\n\nP::ITensor: Probability tensor representing measurement results.\nu::Vector{ITensor}: Vector of local unitary transformations.\nG::Vector{Float64} (optional): Vector of G values to account for measurement errors (default: 1.0 for all sites).\n\nReturns\n\nA DenseShadow object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_dense_shadows-Tuple{MeasurementGroup{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.get_dense_shadows","text":"get_dense_shadows(measurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting};\n                  G::Vector{Float64} = fill(1.0, N),\n                  number_of_ru_batches::Int = NU)\n\nCompute dense shadows for the provided measurement data in batches.\n\nArguments\n\nmeasurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting}: Measurement data object.\nG::Vector{Float64} (optional): Vector of G values for robustness (default: 1.0 for all sites).\nnumber_of_ru_batches::Int (optional): Number of random unitary batches (default: NU).\n\nReturns\n\nA Vector of DenseShadow objects.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, DenseShadow}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadow::DenseShadow)\n\nCompute the expectation value of an MPO operator O using a dense shadow.\n\nArguments:\n\nO::MPO: The MPO operator for which the expectation value is computed.\nshadow::DenseShadow: A dense shadow object.\n\nReturns:\n\nThe expectation value as a ComplexF64 (or Float64 if purely real).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.multiply-Tuple{DenseShadow, DenseShadow}","page":"Home","title":"RandomMeas.multiply","text":"multiply(shadow1::DenseShadow, shadow2::DenseShadow)\n\nCompute the trace product of two dense shadows.\n\nArguments\n\nshadow1::DenseShadow: The first dense shadow.\nshadow2::DenseShadow: The second dense shadow.\n\nReturns\n\nA new DenseShadow object that represents the trace product of the two input shadows.\n\nNotes\n\nThe shadows must have the same site indices (ξ) and number of qubits (N).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_trace-Tuple{DenseShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_trace","text":"partial_trace(shadow::DenseShadow, subsystem::Vector{Int})\n\nCompute the partial trace of a DenseShadow object over the complement of the specified subsystem.\n\nArguments\n\nshadow::DenseShadow: The dense shadow to compute the partial trace for.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns\n\nA new DenseShadow object reduced to the specified subsystem.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_transpose-Tuple{DenseShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(shadow::DenseShadow, subsystem::Vector{Int})::DenseShadow\n\nCompute the partial transpose of a DenseShadow over the specified subsystem by swapping, for each site, the unprimed index with its primed partner. This is done using the swapind function, which returns a view of the underlying ITensor.\n\nArguments\n\nshadow::DenseShadow: The dense classical shadow.\nsubsystem::Vector{Int}: A vector of 1-based site indices on which to perform the partial transpose.\n\nReturns\n\nA new DenseShadow with the specified sites partially transposed.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.trace-Tuple{DenseShadow}","page":"Home","title":"RandomMeas.trace","text":"trace(shadow::DenseShadow)\n\nCompute the trace of a DenseShadow object.\n\nArguments\n\nshadow::DenseShadow: The DenseShadow object whose trace is to be computed.\n\nReturns\n\nThe trace of the shadow as a Float64 or ComplexF64.\n\nNotes\n\nThe function contracts the ξ and ξ' indices of the shadow's ITensor.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.ShallowShadow-Tuple{Vector{Int64}, Vector{ITensor}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.ShallowShadow","text":"ShallowShadow(measurement_results::Vector{Int}, local_unitary::Vector{ITensor};\n                 G::Vector{Float64} = fill(1.0, length(local_unitary)))\n\nConstruct a ShallowSShadow object from raw measurement results and unitary transformations.\n\nArguments\n\nmeasurement_results::Vector{Int}: Vector of binary measurement results for each qubit/site.\nlocal_unitary::Vector{ITensor}: Vector of local unitary transformations applied during the measurement.\n\nReturns\n\nA ShallowShadow object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.apply_map-Tuple{Vector{ITensor}, MPO, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.apply_map","text":"apply_map(map::MPO,state::MPO,s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nApply a map map((s,s')→(ξ,ξ')) on a state of indices (ξ,ξ')\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_depolarization_map-Tuple{MPS, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.get_depolarization_map","text":"get_depolarization_map(depolarization_mps::MPS,s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nreturns a shallow map \\mathcal{M} parametrization by a depolarizationmps c(\\nu)  where the state is depolarized over partition \\A{ u} with probability c(\\nu)=1\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_depolarization_map-Tuple{Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.get_depolarization_map","text":"get_depolarization_map(depolarization_mps::MPS,s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nreturns a shallow map \\mathcal{M} parametrization by a depolarizationmps c(\\nu)  where the state is depolarized over partition \\A{ u} with probability c(\\nu)=1\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, MeasurementData{ShallowUnitaryMeasurementSetting}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, measurement_data::MeasurementData{ShallowUnitaryMeasurementSetting}, inverse_shallow_map::Vector{ITensor},s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nCompute the expectation value of an MPO operator O from a shallow MeasurementData and and inverse shallow_map\n\nReturns:\n\nThe expectation value as a ComplexF64 (or Float64 if purely real).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, ShallowShadow}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadow::ShallowShadow)\n\nCompute the expectation value of an MPO operator O using a shallow shadow.\n\nArguments:\n\nO::MPO: The MPO operator for which the expectation value is computed.\nshadow::ShallowShadow: A factorized shadow object.\n\nReturns:\n\nThe expectation value as a ComplexF64 (or Float64 if purely real).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_shallow_depolarization_mps-Tuple{MeasurementGroup{ShallowUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.get_shallow_depolarization_mps","text":"get_shallow_depolarization_mps(group::MeasurementGroup{ShallowUnitaryMeasurementSetting})\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_shallow_shadows-Tuple{MeasurementData{ShallowUnitaryMeasurementSetting}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.get_shallow_shadows","text":"get_shallow_shadows(measurement_data::MeasurementData{ShallowUnitaryMeasurementSetting}, inverse_shallow_map::Vector{ITensor},s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nConstruct a ShallowSShadow object from MeasurementData\n\nArguments\n\nReturns\n\nA ShallowShadow object.\n\n\n\n\n\n","category":"method"},{"location":"#Simulating-quantum-circuits","page":"Home","title":"Simulating quantum circuits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RandomMeas]\nPages = [\"Circuits.jl\"]","category":"page"},{"location":"#RandomMeas.apply_depo_channel-Tuple{MPO, Vector{Float64}}","page":"Home","title":"RandomMeas.apply_depo_channel","text":"apply_depo_channel(ρ::MPO, p::Vector{Float64})\n\nApply a local depolarization channel to an MPO by modifying each site tensor according to the depolarization probability.\n\nFor each site, the channel acts as:\n\nρ[i] → (1 - p[i]) * ρ[i] + (p[i] / 2) * (ρ[i] * δ(s, s') * δ(s, s'))\n\nwhere δ(s, s') is the delta tensor that contracts the site index with its primed counterpart.\n\nArguments\n\nρ::MPO: The input Matrix Product Operator representing a density matrix.\np::Vector{Float64}: A vector of depolarization probabilities, one per site.\n\nReturns\n\nAn MPO with the depolarization channel applied on each site.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.apply_depo_channel-Tuple{MPS, Vector{Float64}}","page":"Home","title":"RandomMeas.apply_depo_channel","text":"apply_depo_channel(ψ::MPS, p::Vector{Float64})\n\nApply the local depolarization channel to an MPS by converting it to an MPO density matrix (using the outer product) and then applying the depolarization channel.\n\nArguments\n\nψ::MPS: The input Matrix Product State representing a pure state.\np::Vector{Float64}: A vector of depolarization probabilities, one per site.\n\nReturns\n\nAn MPO representing the depolarized density matrix.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.random_Pauli_layer-Tuple{Vector{Index{Int64}}, Vector{Float64}}","page":"Home","title":"RandomMeas.random_Pauli_layer","text":"random_Pauli_layer(ξ::Vector{Index{Int64}}, p::Vector{Float64})\n\nConstruct a layer of random single-qubit Pauli operations to simulate local depolarization. Upon avereraging, this corresponds to the local depolarization channel with strength p.\n\nFor each qubit (with index i), a random Pauli operation is applied with the following probabilities:\n\nWith probability 1 - 3p_i/4: No operation is applied (the qubit remains unchanged).\nWith probability p_i/4} each: Apply the X, Y, or Z gate.\n\nHere, p_i is the depolarization probability for qubit i.\n\nArguments\n\nξ::Vector{Index{Int64}}: A vector of ITensor indices representing the qubit sites.\np::Vector{Float64}: A vector of depolarization probabilities (one per qubit).\n\nReturns\n\nA vector of ITensors representing the applied Pauli gates. If no gate is applied on a site (with probability 1 - 3p_i/4, that site is omitted from the returned circuit.\n\nExample\n\ncircuit = random_Pauli_layer(siteinds(\"Qubit\", 5), 0.05 * ones(5))\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.random_circuit-Tuple{Vector{Index{Int64}}, Int64}","page":"Home","title":"RandomMeas.random_circuit","text":"random_circuit(ξ::Vector{Index{Int64}}, depth::Int64)\n\nCreate a random circuit of the given depth. The function returns a vector of ITensors, each representing a gate in the circuit.\n\nIf depth == 0, a single-qubit random unitary is applied to each site.\nFor depth > 0, the circuit is built layer-by-layer:\nOn odd layers, random two-qubit gates are applied on sites 1-2, 3-4, etc.\nOn even layers, random two-qubit gates are applied on sites 2-3, 4-5, etc.\n\nArguments\n\nξ::Vector{Index{Int64}}: A vector of site indices for the qubits.\ndepth::Int64: The depth of the circuit (non-negative integer).\n\nReturns\n\nA vector of ITensors representing the random circuit gates.\n\nExample\n\ncircuit = random_circuit(siteinds(\"Qubit\", 10), 3)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.random_magnetic_field_layer-Tuple{Vector{Index{Int64}}, Vector{Float64}}","page":"Home","title":"RandomMeas.random_magnetic_field_layer","text":"random_magnetic_field_layer(ξ::Vector{Index{Int64}}, p::Vector{Float64})\n\nConstruct a layer of random Rz gates representing a random magnetic field along the z-axis.\n\nFor each qubit i, a random rotation Rz is applied with a rotation angle drawn uniformly from [0, 2 pi pi). This gives an average rotation angle of pi pi on each site.\n\nArguments\n\nξ::Vector{Index{Int64}}: A vector of ITensor indices corresponding to the qubit sites.\np::Vector{Float64}: A vector of parameters (one per qubit) that set the scale of the rotation angles.\n\nReturns\n\nA vector of ITensors representing the random Rz gates applied to each qubit.\n\nExample\n\ncircuit = random_magnetic_field_layer(siteinds(\"Qubit\", 5), 0.1 * ones(5))\n\n\n\n\n\n","category":"method"},{"location":"#Additional-useful-routines-for-ITensor","page":"Home","title":"Additional useful routines for ITensor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RandomMeas]\nPages = [\"TensorNetworkUtilities.jl\"]","category":"page"},{"location":"#RandomMeas.flatten-Tuple{Union{MPO, MPS, Vector{ITensor}}}","page":"Home","title":"RandomMeas.flatten","text":"flatten(O::Union{MPS, MPO, Vector{ITensor}})\n\nFlatten a Matrix Product State (MPS), Matrix Product Operator (MPO), or a vector of ITensors into a single ITensor by sequentially multiplying the constituent tensors.\n\nArguments\n\nO: An MPS, MPO, or vector of ITensors to be flattened.\n\nReturns\n\nAn ITensor representing the product of the individual tensors in O.\n\nExample\n\nA = random_mps(siteinds(\"Qubit\", 5))\nflatA = flatten(A)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_Born_MPS-Tuple{MPO}","page":"Home","title":"RandomMeas.get_Born_MPS","text":"get_Born_MPS(ρ::MPO)\n\nConstruct the Born probability vector as an MPS from an MPO representation of a density matrix ρ.\n\nThis function computes the Born probability vector P(s) = ⟨s|ρ|s⟩, where |s⟩ is a basis state. It does so by contracting each tensor of the MPO ρ with appropriate delta tensors that enforce equality between the unprimed and primed indices. The result is returned as an MPS that represents the Born probabilities over the computational basis.\n\nArguments\n\nρ::MPO: A Matrix Product Operator representing the density matrix.\n\nReturns\n\nAn MPS representing the Born probability vector.\n\nExample\n\nP = get_Born_MPS(ρ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_Born_MPS-Tuple{MPS}","page":"Home","title":"RandomMeas.get_Born_MPS","text":"get_Born_MPS(ψ::MPS)\n\nConstruct the Born probability vector P(s) = |ψ(s)|² as an MPS from an MPS representation ψ.\n\nThis function computes the probability for each computational basis state by contracting each tensor of the MPS ψ with its complex conjugate, using appropriate delta tensors to enforce index equality. The resulting MPS represents the Born probability distribution of the state.\n\nArguments\n\nψ::MPS: A matrix product state representing a pure quantum state.\n\nReturns\n\nAn MPS representing the Born probability vector, where each tensor P[i] corresponds to the probability contribution at site i.\n\nExample\n\nP = get_Born_MPS(ψ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_average_mps-Tuple{Vector{MPS}, Int64, Int64}","page":"Home","title":"RandomMeas.get_average_mps","text":"get_average_mps(ψ_list::Vector{MPS}, χ::Int64, nsweeps::Int64)\n\nApproximate the average state σ from a collection of MPS using a DMRG-like algorithm.\n\nThe algorithm finds an MPS ψ (with maximum bond dimension χ) that approximates the average state σ = Average(ψ_list). To monitor convergence, it tracks a cost function defined as:\n\ncost_function = ⟨ψ|ψ⟩ - ⟨ψ|σ⟩ - ⟨σ|ψ⟩,\n\nwhich is equivalent to (||σ - ψ||² - ⟨σ|σ⟩).\n\nArguments\n\nψ_list::Vector{MPS}: A vector of MPS objects representing individual quantum states.\nχ::Int64: The desired maximum bond dimension for the averaged MPS.\nnsweeps::Int64: The number of sweeps (iterations) to perform in the DMRG-like algorithm.\n\nReturns\n\nAn MPS representing the approximate average state with bond dimension χ.\n\nExample\n\navg_state = get_average_mps(ψ_list, 20, 10)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_entanglement_spectrum-Tuple{MPS, Int64}","page":"Home","title":"RandomMeas.get_entanglement_spectrum","text":"get_entanglement_spectrum(ψ::MPS, NA::Int64)\n\nCompute the entanglement spectrum for the bipartition defined by the first NA sites of the MPS ψ.\n\nThis function first creates a copy of ψ and orthogonalizes it up to site NA. Then, it performs an SVD on the tensor at site NA:\n\nIf NA > 1, the SVD is taken with respect to the indices corresponding to the link between sites NA-1 and NA and the physical index at site NA.\nIf NA == 1, only the physical index at site NA is used.\n\nThe returned object spec contains the singular values (which are related to the Schmidt coefficients) for the bipartition.\n\nArguments\n\nψ::MPS: A matrix product state representing a pure quantum state.\nNA::Int64: The number of sites from the left that define the subsystem for which the entanglement spectrum is computed.\n\nReturns\n\nspec: An ITensor containing the singular values from the SVD at site NA.\n\nExample\n\nspectrum = get_entanglement_spectrum(ψ, 3)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_selfXEB-Tuple{MPS}","page":"Home","title":"RandomMeas.get_selfXEB","text":"get_selfXEB(ψ::MPS)\n\nCompute the self-XEB (cross-entropy benchmarking) metric for a pure state represented as an MPS.\n\nThe self-XEB is defined as:\n\nselfXEB = 2^N * ∑ₛ |ψ(s)|⁴ - 1\n\nwhere the sum is over all computational basis states s and N is the number of sites (qubits). This function first computes the Born probability MPS from ψ, then calculates the inner product of the probability MPS with itself, scales the result by 2^N, and finally subtracts 1.\n\nArguments\n\nψ::MPS: A Matrix Product State representing a pure quantum state.\n\nReturns\n\nA scalar (Float64) representing the self-XEB value.\n\nExample\n\nx = get_selfXEB(ψ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_siteinds-Tuple{Union{MPO, MPS}}","page":"Home","title":"RandomMeas.get_siteinds","text":"get_siteinds(ψ::Union{MPS, MPO})\n\nRetrieve the site indices for a quantum state represented as an MPS or MPO.\n\nArguments\n\nψ: The quantum state, which can be either a Matrix Product State (MPS) or a Matrix Product Operator (MPO).\n\nReturns\n\nA vector of site indices corresponding to the quantum state ψ.\n\nExample\n\nξ = get_siteinds(ψ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace-Tuple{MPO}","page":"Home","title":"RandomMeas.get_trace","text":"get_trace(ρ::MPO)\n\nCompute the trace of a Matrix Product Operator (MPO) ρ by contracting each tensor with a delta function that equates its unprimed and primed indices.\n\nArguments\n\nρ::MPO: A matrix product operator representing a quantum state or operator.\n\nReturns\n\nA scalar representing the trace of ρ.\n\nExample\n\nt = get_trace(ρ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moment","page":"Home","title":"RandomMeas.get_trace_moment","text":"get_trace_moment(ψ::Union{MPS, MPO}, k::Int, subsystem::Vector{Int}=collect(1:length(ψ)))\n\nCompute the kth trace moment of the reduced density matrix for a given subsystem of a quantum state.\n\nFor a pure state (MPS) and when the subsystem is contiguous starting from site 1, the function computes the entanglement spectrum of the bipartition defined by the last site in subsystem and returns the kth moment of the squared Schmidt coefficients. Otherwise, the function reduces the state to the specified subsystem.\n\nFor k = 2 (purity), it returns the squared norm (which is equivalent to tr(ρ²)). For k > 2, it computes ρ^k via repeated application of the apply function (with a cutoff) and returns the trace of the resulting tensor.\n\nArguments\n\nψ::Union{MPS, MPO}: The quantum state, represented as an MPS (for pure states) or MPO (for mixed states).\nk::Int: The moment order to compute (must be an integer ≥ 1).\nsubsystem::Vector{Int} (optional): A vector of site indices (1-based) specifying the subsystem to retain. Defaults to all sites.\n\nReturns\n\nA scalar (Float64) representing the kth trace moment of the reduced density matrix.\n\nExample\n\nmoment = get_trace_moment(ψ, 3, [1, 2, 3]; partial_transpose=false)\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.get_trace_moment-Tuple{ITensor, Int64}","page":"Home","title":"RandomMeas.get_trace_moment","text":"get_trace_moment(spec::ITensor, k::Int)\n\nCompute the kth moment of the entanglement spectrum represented by the ITensor spec.\n\nThe function assumes that spec is a square ITensor whose diagonal elements correspond to the singular values (Schmidt coefficients) of a reduced density matrix. The kth moment is computed as:\n\npk = ∑ₗ (spec[l, l]^(2*k))\n\nwhich effectively computes the sum over the kth powers of the squared singular values.\n\nArguments\n\nspec::ITensor: A square ITensor representing the entanglement spectrum.\nk::Int: The moment order to compute (must be an integer ≥ 1).\n\nReturns\n\nA scalar (Float64) corresponding to the kth moment.\n\nExample\n\nmoment = get_trace_moment(spec, 2)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moments","page":"Home","title":"RandomMeas.get_trace_moments","text":"get_trace_moments(ψ::Union{MPS, MPO}, k_vector::Vector{Int}, subsystem::Vector{Int}=collect(1:length(ψ)))\n\nCompute a vector of trace moments for a quantum state ψ over a specified subsystem.\n\nFor each moment order k in k_vector, the function computes the kth trace moment of the reduced density matrix obtained by applying reduce_to_subsystem(ψ, subsystem).\n\nArguments\n\nψ::Union{MPS, MPO}: The quantum state, represented as an MPS (for pure states) or an MPO (for mixed states).\nk_vector::Vector{Int}: A vector of integer moment orders (each ≥ 1) for which the trace moments are computed.\nsubsystem::Vector{Int} (optional): A vector of site indices (1-based) specifying the subsystem to consider. Defaults to all sites.\n\nReturns\n\nA vector of scalars, each being the kth trace moment corresponding to the entries of k_vector.\n\nExample\n\nmoments = get_trace_moments(ψ, [1, 2, 3], [1, 2, 3])\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.partial_transpose-Tuple{MPO, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(ρ::MPO, subsystem::Vector{Int})\n\nCompute the partial transpose of an MPO over the sites specified by subsystem.\n\nFor each site index in the MPO:\n\nIf the index is in the subsystem, the tensor is transposed by swapping its unprimed and primed indices using swapind.\nOtherwise, the tensor is left unchanged (multiplied by 1.0 for type consistency).\n\nArguments\n\nρ::MPO: A Matrix Product Operator representing a density matrix.\nsubsystem::Vector{Int}: A vector of site indices (1-based) over which to apply the transpose.\n\nReturns\n\nAn MPO in which the tensors corresponding to the sites in subsystem have been partially transposed.\n\nExample\n\nρT = partial_transpose(ρ, [2, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.reduce_to_subsystem","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(ρ::MPO, subsystem::Vector{Int64})\n\nCompute the reduced density matrix (as an MPO) for a specified subsystem.\n\nArguments\n\nρ::MPO: A Matrix Product Operator representing the full density matrix.\nsubsystem::Vector{Int64}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns\n\nAn MPO representing the reduced density matrix over the sites specified in subsystem.\n\nExample\n\nρ_reduced = reduce_to_subsystem(ρ, [2, 3])\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.reduce_to_subsystem-Tuple{MPS, Vector{Int64}}","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(ψ::MPS, subsystem::Vector{Int64})\n\nCompute the reduced density matrix for a pure state represented by the MPS ψ over the specified subsystem.\n\nThis function first constructs the density matrix by taking the outer product of ψ with itself, and then applies the MPO version of reduce_to_subsystem to obtain the reduced density matrix for the sites specified in subsystem.\n\nArguments\n\nψ::MPS: A Matrix Product State representing a pure quantum state.\nsubsystem::Vector{Int64}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns\n\nAn MPO representing the reduced density matrix over the specified subsystem.\n\nExample\n\nρ_sub = reduce_to_subsystem(ψ, [2, 3])\n\n\n\n\n\n","category":"method"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Classical-shadows","page":"Home","title":"Classical shadows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Energy/Energy variance measurements with classical shadows\nRobust Shadow tomography\nProcess Shadow tomography\nClassical shadows with shallow circuits\nVirtual distillation","category":"page"},{"location":"#Quantum-benchmark","page":"Home","title":"Quantum benchmark","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Cross-Entropy/Self-Cross entropy benchmarking\nFidelities from common randomized measurements\nCross-Platform verification","category":"page"},{"location":"#Entanglement","page":"Home","title":"Entanglement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Entanglement entropy of pure states\"\nAnalyzing the experimental data of Brydges et al, Science 2019\nSurface code and the measurement of the topological entanglement entropy\nMixed-state entanglement: The p3-PPT condition and batch shadows","category":"page"},{"location":"#Miscellanous","page":"Home","title":"Miscellanous","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Noisy circuit simulations with tensor networks\nEstimating statistical error bars via Jackknife resampling\nExecuting randomized measurements on IBM's quantum computers","category":"page"}]
}
