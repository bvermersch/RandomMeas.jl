var documenterSearchIndex = {"docs":
[{"location":"#RandomMeas","page":"Home","title":"RandomMeas","text":"Documentation for RandomMeas.jl: The randomized measurement toolbox in Julia. \n\nDetailed information and context is also presented in our  publication.\n\nDepth = 2:3","category":"section"},{"location":"#Data-acquisition","page":"Home","title":"Data acquisition","text":"","category":"section"},{"location":"#Data-acquisition-types","page":"Home","title":"Data acquisition types","text":"","category":"section"},{"location":"#Data-acquisition-routines","page":"Home","title":"Data acquisition routines","text":"","category":"section"},{"location":"#Postprocessing-(excluding-classical-shadows)","page":"Home","title":"Postprocessing (excluding classical shadows)","text":"","category":"section"},{"location":"#Postprocessing-for-classical-shadows","page":"Home","title":"Postprocessing for classical shadows","text":"","category":"section"},{"location":"#Classical-shadow-types","page":"Home","title":"Classical shadow types","text":"","category":"section"},{"location":"#Classical-shadow-routines","page":"Home","title":"Classical shadow routines","text":"","category":"section"},{"location":"#Simulating-quantum-circuits","page":"Home","title":"Simulating quantum circuits","text":"","category":"section"},{"location":"#Additional-useful-routines-for-ITensor","page":"Home","title":"Additional useful routines for ITensor","text":"","category":"section"},{"location":"#Types-and-other-functions","page":"Home","title":"Types and other functions","text":"","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Classical-shadows","page":"Home","title":"Classical shadows","text":"Energy/Energy variance measurements with classical shadows\nRobust Shadow tomography\nProcess Shadow tomography\nClassical shadows with shallow circuits\nVirtual distillation","category":"section"},{"location":"#Quantum-benchmark","page":"Home","title":"Quantum benchmark","text":"Cross-Entropy/Self-Cross entropy benchmarking\nFidelities from common randomized measurements\nCross-Platform verification","category":"section"},{"location":"#Entanglement","page":"Home","title":"Entanglement","text":"Entanglement entropy of pure states\"\nAnalyzing the experimental data of Brydges et al, Science 2019\nSurface code and the measurement of the topological entanglement entropy\nMixed-state entanglement: The p3-PPT condition and batch shadows","category":"section"},{"location":"#Miscellanous","page":"Home","title":"Miscellanous","text":"Noisy circuit simulations with tensor networks\nEstimating statistical error bars via Jackknife resampling\nExecuting randomized measurements on IBM's quantum computers","category":"section"},{"location":"#RandomMeas.AbstractMeasurementSetting","page":"Home","title":"RandomMeas.AbstractMeasurementSetting","text":"AbstractMeasurementSetting\n\nAn abstract type representing a general measurement setting. Concrete implementations (e.g. LocalUnitaryMeasurementSetting, ComputationalBasisMeasurementSetting) should subtype this.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ComputationalBasisMeasurementSetting","page":"Home","title":"RandomMeas.ComputationalBasisMeasurementSetting","text":"ComputationalBasisMeasurementSetting(N, basis_transformation, site_indices)\n\nA struct representing computational basis measurement settings for quantum systems. This setting uses the computational basis, so that each local unitary is by construction simply the identity operator.\n\nFields\n\nN::Int: Number of sites (qubits).\nbasis_transformation::Vector{ITensor}: A vector of N identity ITensors.\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nConstraints\n\nN == length(site_indices).\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ComputationalBasisMeasurementSetting-Tuple{ComputationalBasisMeasurementSetting}","page":"Home","title":"RandomMeas.ComputationalBasisMeasurementSetting","text":"ComputationalBasisMeasurementSetting(ms::ComputationalBasisMeasurementSetting; N=ms.N, basis_transformation=ms.basis_transformation, site_indices=ms.site_indices)\n\nMake a new ComputationalBasisMeasurementSetting by copying fields from ms, but overriding any that you pass by keyword.\n\nArguments\n\nms::ComputationalBasisMeasurementSetting: The original measurement setting to copy from.\nN (optional): Override the number of sites. Default is ms.N.\nbasis_transformation (optional): Override the basis transformation. Default is ms.basis_transformation.\nsite_indices (optional): Override the site indices. Default is ms.site_indices.\n\nReturns\n\nA new ComputationalBasisMeasurementSetting object with the specified overrides.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.LocalMeasurementSetting","page":"Home","title":"RandomMeas.LocalMeasurementSetting","text":"LocalMeasurementSetting\n\nAn abstract type for measurement settings that correspond to local (i.e. single qubit/site) measurements.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.LocalUnitaryMeasurementSetting","page":"Home","title":"RandomMeas.LocalUnitaryMeasurementSetting","text":"LocalUnitaryMeasurementSetting(N, basis_transformation, site_indices)\n\nA measurement setting where each qubit is specified by a single-qubit rotation. Rotates from the computational basis into the measurement basis.\n\nFields\n\nN::Int: Number of sites (qubits).\nbasis_transformation::Vector{ITensor}: A vector of N ITensors representing the local unitary basis rotations.\nsite_indices::Vector{Index{Int64}}: A vector of site indices of length N.\n\nConstraints\n\nN == length(basis_transformation) == length(site_indices).\nEach ITensor in basis_transformation has exactly two indices:\nOne unprimed (site_indices[i])\nOne primed (prime(site_indices[i])).\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.LocalUnitaryMeasurementSetting-Tuple{LocalUnitaryMeasurementSetting}","page":"Home","title":"RandomMeas.LocalUnitaryMeasurementSetting","text":"LocalUnitaryMeasurementSetting(ms::LocalUnitaryMeasurementSetting; N=ms.N, basis_transformation=ms.basis_transformation, site_indices=ms.site_indices)\n\nMake a new LocalUnitaryMeasurementSetting by copying fields from ms, but overriding any that you pass by keyword.\n\nArguments\n\nms::LocalUnitaryMeasurementSetting: The original measurement setting to copy from.\nN (optional): Override the number of sites. Default is ms.N.\nbasis_transformation (optional): Override the basis transformation. Default is ms.basis_transformation.\nsite_indices (optional): Override the site indices. Default is ms.site_indices.\n\nReturns\n\nA new LocalUnitaryMeasurementSetting object with the specified overrides.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementData","page":"Home","title":"RandomMeas.MeasurementData","text":"MeasurementData{T}(N, NM, measurement_results, measurement_setting)\n\nA container for measurement data and settings obtained in actual or simulated quantum experiments.\n\nFields\n\nN::Int: Number of sites (qubits).\nNM::Int: Number of measurements per setting.\nmeasurement_results::Array{Int, 2}: A 2D array of binary measurement results with dimensions (NM, N).\nmeasurement_setting::T: A measurement setting of type T (subtype of AbstractMeasurementSetting) or nothing.\n\nType Parameter\n\nT: The type of the measurement setting, constrained to Union{Nothing, AbstractMeasurementSetting}.\n\nUsage\n\nTypically constructed via the provided constructors.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.MeasurementGroup","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup{T}(N, NU, NM, measurements)\n\nA container for a group of measurement data objects used in actual or simulated quantum experiments.\n\nFields\n\nN::Int: Number of sites (qubits).\nNU::Int: Number of measurement data objects.\nNM::Int: Number of measurements per setting.\nmeasurements::Vector{MeasurementData{T}}: A vector of measurement data objects.\n\nType Parameter\n\nT: The type of the measurement setting for each measurement data object, constrained to Union{Nothing, AbstractMeasurementSetting}.\n\nUsage\n\nTypically constructed via one of the provided constructors.\n\nExample\n\n# Assume setting1 and setting2 are valid measurement settings\ndata1 = MeasurementData(results1; measurement_setting=setting1)\ndata2 = MeasurementData(results2; measurement_setting=setting2)\ngroup = MeasurementGroup([data1, data2])\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.MeasurementProbability","page":"Home","title":"RandomMeas.MeasurementProbability","text":"MeasurementProbability{T}(N, measurement_probability, measurement_setting, site_indices)\n\nA container for measurement probabilities and settings obtained either estimated from measurement data or directly computed from quantum states.\n\nFields\n\nN::Int: Number of sites (qubits).\nmeasurement_probability::ITensor: An ITensor representing Born probability.\nmeasurement_setting::T: A measurement setting of type T or nothing.\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nType Parameter\n\nT: The type of measurement setting, constrained to Union{Nothing, AbstractMeasurementSetting}.\n\nUsage\n\nConstructed either from measurement data or directly from quantum states.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ShallowUnitaryMeasurementSetting","page":"Home","title":"RandomMeas.ShallowUnitaryMeasurementSetting","text":"ShallowUnitaryMeasurementSetting(N, K, basis_transformation, site_indices)\n\nA struct representing shallowmeasurement settings which is specified by a list of one and two qubit gates.\n\nFields\n\nN::Int: Number of sites (qubits).\nK::Int: Number of gates that creates the shallow unitary.\nbasis_transformation::Vector{ITensor}: A vector of K ITensors representing the shallow unitary.\nsite_indices::Vector{Index{Int64}}: A vector of site indices of length N.\n\nConstraints\n\nlength(basis_transformation) == K.\nlength(site_indices) == N.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ShallowUnitaryMeasurementSetting-Tuple{ShallowUnitaryMeasurementSetting}","page":"Home","title":"RandomMeas.ShallowUnitaryMeasurementSetting","text":"ShallowUnitaryMeasurementSetting(ms::ShallowUnitaryMeasurementSetting; N=ms.N, K=ms.K, basis_transformation=ms.basis_transformation, site_indices=ms.site_indices)\n\nMake a new ShallowUnitaryMeasurementSetting by copying fields from ms, but overriding any that you pass by keyword.\n\nArguments\n\nms::ShallowUnitaryMeasurementSetting: The original measurement setting to copy from.\nN (optional): Override the number of sites. Default is ms.N.\nK (optional): Override the number of gates. Default is ms.K.\nbasis_transformation (optional): Override the basis transformation. Default is ms.basis_transformation.\nsite_indices (optional): Override the site indices. Default is ms.site_indices.\n\nReturns\n\nA new ShallowUnitaryMeasurementSetting object with the specified overrides.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.ComputationalBasisMeasurementSetting-Tuple{Int64}","page":"Home","title":"RandomMeas.ComputationalBasisMeasurementSetting","text":"ComputationalBasisMeasurementSetting(N; site_indices=nothing)\n\nCreate a ComputationalBasisMeasurementSetting for N sites. This setting corresponds to measurement in the computational basis.\n\nArguments\n\nN::Int: Number of sites (qubits).\nsite_indices::Union{Vector{Index{Int64}}, Nothing} (optional): Site indices. If nothing, they are automatically generated.\n\nReturns\n\nA ComputationalBasisMeasurementSetting object.\n\nExample\n\nsetting = ComputationalBasisMeasurementSetting(4)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.LocalUnitaryMeasurementSetting-Tuple{Array{ComplexF64, 3}}","page":"Home","title":"RandomMeas.LocalUnitaryMeasurementSetting","text":"LocalUnitaryMeasurementSetting(basis_transformation_array; site_indices=nothing)\n\nCreate a LocalUnitaryMeasurementSetting object from an N × 2 × 2 array of unitary matrices.\n\nArguments\n\nbasis_transformation_array::Array{ComplexF64, 3}: An N × 2 × 2 array of unitary matrices.\nsite_indices::Union{Vector{Index{Int64}}, Nothing} (optional): Site indices. If nothing, they are automatically generated.\n\nReturns\n\nA LocalUnitaryMeasurementSetting object.\n\nExample\n\nunitary_array = rand(ComplexF64, 4, 2, 2)\nsetting = LocalUnitaryMeasurementSetting(unitary_array)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.LocalUnitaryMeasurementSetting-Tuple{Int64}","page":"Home","title":"RandomMeas.LocalUnitaryMeasurementSetting","text":"LocalUnitaryMeasurementSetting(N; site_indices=nothing, ensemble=Haar)\n\nCreate a LocalUnitaryMeasurementSetting object by randomly sampling local unitary operators.\n\nArguments\n\nN::Int: Number of sites (qubits).\nsite_indices::Union{Vector{Index{Int64}}, Nothing} (optional): Site indices. If nothing, they are automatically generated.\nensemble::UnitaryEnsemble: Type of random unitary (Haar, Pauli, Identity).\n\nReturns\n\nA LocalUnitaryMeasurementSetting object.\n\nExample\n\nsetting = LocalUnitaryMeasurementSetting(4, ensemble=Haar)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.ShallowUnitaryMeasurementSetting-Tuple{Int64, Int64}","page":"Home","title":"RandomMeas.ShallowUnitaryMeasurementSetting","text":"ShallowUnitaryMeasurementSetting(N, depth; site_indices=nothing)\n\nCreate a ShallowUnitaryMeasurementSetting object by generating a random quantum circuit.\n\nArguments\n\nN::Int: Number of sites (qubits).\ndepth::Int: Depth of the random circuit.\nsite_indices::Union{Vector{Index{Int64}}, Nothing} (optional): Site indices. If nothing, they are automatically generated.\n\nReturns\n\nA ShallowUnitaryMeasurementSetting object.\n\nExample\n\nsetting = ShallowUnitaryMeasurementSetting(4, 3)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.export_LocalUnitaryMeasurementSetting-Tuple{LocalUnitaryMeasurementSetting, String}","page":"Home","title":"RandomMeas.export_LocalUnitaryMeasurementSetting","text":"export_LocalUnitaryMeasurementSetting(ms, filepath)\n\nExport the unitary in a LocalUnitaryMeasurementSetting object to an .npz file with a single field: basis_transformation.\n\nArguments\n\nms::LocalUnitaryMeasurementSetting: The measurement settings to export.\nfilepath::String: Path to the output .npz file.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_rotation","page":"Home","title":"RandomMeas.get_rotation","text":"get_rotation(site_index, ensemble=Haar)\n\nGenerate a single-qubit unitary sampled from a specified ensemble.\n\nArguments\n\nsite_index::Index{Int64}: Site index.\nensemble::UnitaryEnsemble: Type of unitary ensemble (Haar, Pauli, Identity).\n\nReturns\n\nAn ITensor representing the unitary transformation.\n\nExample\n\nU = get_rotation(site_index, Pauli)\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.import_LocalUnitaryMeasurementSetting-Tuple{String}","page":"Home","title":"RandomMeas.import_LocalUnitaryMeasurementSetting","text":"import_LocalUnitaryMeasurementSetting(filepath; site_indices=nothing)\n\nImport unitary from an .npz file and create a LocalUnitaryMeasurementSetting object.\n\nArguments\n\nfilepath::String: Path to the input .npz file.\nsite_indices::Union{Vector{Index{Int64}}, Nothing} (optional): Site indices. If not provided, they will be generated.\n\nReturns\n\nA LocalUnitaryMeasurementSetting object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.reduce_to_subsystem-Tuple{LocalMeasurementSetting, Vector{Int64}}","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(settings, subsystem)\n\nReduce a LocalMeasurementSetting object to a specified subsystem.\n\nArguments\n\nsettings::LocalMeasurementSetting: The original measurement settings object.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns\n\nA new LocalMeasurementSetting object corresponding to the specified subsystem.\n\nExample\n\nreduced_setting = reduce_to_subsystem(full_setting, [1, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementData-Tuple{Union{MPO, MPS}, Int64, Union{ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting, ShallowUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.MeasurementData","text":"MeasurementData(ψ::Union{MPO, MPS}, NM::Int, measurement_setting::Union{LocalUnitaryMeasurementSetting, ComputationalBasisMeasurementSetting, ShallowUnitaryMeasurementSetting}; mode::SimulationMode = TensorNetwork)\n\nReturns a MeasurementData object by sampling NM projective measurements from the quantum state ψ.\n\nArguments\n\nψ::Union{MPO, MPS}: The quantum state represented as a Matrix Product Operator (MPO) or Matrix Product State (MPS).\nNM::Int: The number of measurement shots to simulate for each setting.\nmode::SimulationMode (optional): Specifies the simulation method. Options:\nDense: Uses the dense representation.\nTensorNetwork (default): Uses tensor network methods for memory efficiency.\nmeasurement_setting: A measurement setting object.\n\nReturns\n\nA MeasurementData object with the corresponding measurement results and setting.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementData-Union{Tuple{Matrix{Int64}}, Tuple{T}} where T<:Union{Nothing, RandomMeas.AbstractMeasurementSetting}","page":"Home","title":"RandomMeas.MeasurementData","text":"MeasurementData(measurement_results::Array{Int, 2}; measurement_setting::Union{T, Nothing} = nothing) where T <: Union{Nothing, AbstractMeasurementSetting}\n\nCreates a MeasurementData object by inferring the dimensions of the measurement results and validating the provided setting.\n\nArguments\n\nmeasurement_results::Array{Int, 2}: A 2D array of binary measurement results with shape (NM, N).\nmeasurement_setting::Union{T, Nothing} (optional): Measurement setting or nothing if not provided, where T <: AbstractMeasurementSetting.\n\nReturns\n\nA MeasurementData object with inferred dimensions and validated setting.\n\nThrows\n\nAssertionError: If the dimensions of measurement_results and measurement_setting are inconsistent.\n\nExamples\n\n# With measurement setting\nsetting = LocalUnitaryMeasurementSetting(4, ensemble=Haar)\nresults = rand(1:2, 10, 4)\ndata_with_setting = MeasurementData(results; measurement_setting=setting)\n\n# Without measurement setting\ndata_without_setting = MeasurementData(rand(1:2, 10, 4))\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementData-Union{Tuple{T}, Tuple{MeasurementProbability{T}, Int64}} where T<:Union{Nothing, RandomMeas.AbstractMeasurementSetting}","page":"Home","title":"RandomMeas.MeasurementData","text":"MeasurementData(probability::MeasurementProbability{T}, NM::Int) where T <: Union{Nothing, AbstractMeasurementSetting}\n\nReturns a MeasurementData object by sampling NM projective measurements based on the provided measurement probability.\n\nArguments\n\nprobability::MeasurementProbability{T}: A container with the measurement probability (an ITensor) and associated settings, where T <: Union{Nothing, AbstractMeasurementSetting}.\nNM::Int: The number of projective measurements to sample.\n\nReturns\n\nA MeasurementData object with dimensions inferred from the measurement probability.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.export_MeasurementData-Union{Tuple{T}, Tuple{MeasurementData{T}, String}} where T<:Union{Nothing, ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting}","page":"Home","title":"RandomMeas.export_MeasurementData","text":"export_MeasurementData(data::MeasurementData{T}, filepath::String) where {T<:Union{Nothing, LocalUnitaryMeasurementSetting,ComputationalBasisMeasurementSetting}}\n\nExports measurement data to a .npz file.\n\nArguments\n\ndata::MeasurementData: The measurement data object containing measurement results and optionally a LocalUnitaryMeasurementSetting setting.\nfilepath::String: The file path where the data will be exported.\n\nDetails\n\nThe measurement_results are exported directly as they are.\nIf measurement_setting is provided, the associated local_unitaries are extracted, reshaped, and included in the export.\n\nNotes\n\nThe exported .npz file will contain:\n\"measurement_results\": A 2D array of shape (NM, N), where:\nNM: Number of measurements per setting.\nN: Number of qubits/sites.\n\"local_unitaries\" (optional): A 4D array of shape (N, 2, 2) representing the unitary transformations for each site.\n\nExample\n\n\n# Create MeasurementData object\ndata = MeasurementData(measurement_results; measurement_setting=measurement_setting)\n\n# Export to a file\nexport_measurement_data(data, \"exported_data.npz\")\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.import_MeasurementData-Tuple{String}","page":"Home","title":"RandomMeas.import_MeasurementData","text":"import_MeasurementData(filepath::String; predefined_setting=nothing, site_indices=nothing)\n\nImports measurement results and optional measurement settings from an archive file.\n\nArguments\n\nfilepath::String: Path to the .npz file containing the measurement results and optionally local unitaries. The file should contain at least a field measurement_results (2D binary array of shape (NM, N)), and optionally a field local_unitaries (local unitaries as a Nx2x2 array).\npredefined_setting (optional): A predefined MeasurementSetting object. If provided, this will be used instead of the file's setting.\nsite_indices (optional): A vector of site indices to be used when constructing LocalUnitaryMeasurementSetting from the field local_unitaries (only relevant if predefined_setting is not provided). If not provided, the default site indices will be generated internally.\n\nReturns\n\nA MeasurementData object containing the imported results and settings.\n\nExamples\n\n# Import with predefined settings\nsetting = LocalUnitaryMeasurementSetting(local_unitaries; site_indices=siteinds(\"Qubit\", 5))\ndata_with_setting = import_measurement_data(\"data.npz\"; predefined_setting=setting)\n\n# Import with site indices provided\ndata_with_indices = import_measurement_data(\"data.npz\"; site_indices=siteinds(\"Qubit\", 5))\n\n# Import without any additional options\ndata = import_measurement_data(\"data.npz\")\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.reduce_to_subsystem-Union{Tuple{T}, Tuple{MeasurementData{T}, Vector{Int64}}} where T<:Union{Nothing, LocalMeasurementSetting}","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(data::MeasurementData{T}, subsystem::Vector{Int}) where T <: Union{Nothing, LocalMeasurementSetting}\n\nReduce a MeasurementData object to a specified subsystem, preserving the measurement setting type if available.\n\nArguments\n\ndata::MeasurementData{T}: The original measurement data object, where T is either nothing or a subtype of LocalMeasurementSetting.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain. Each index must be between 1 and data.N.\n\nReturns\n\nA new MeasurementData{T} object with:\n\nThe measurement results reduced from dimensions (NM, N) to (NM, |subsystem|).\nThe measurement setting reduced accordingly (if one is provided), or remaining as nothing.\n\nExample\n\n# Suppose `data` is a MeasurementData object with N = 4.\n# To retain only sites 1 and 3:\nreduced_data = reduce_to_subsystem(data, [1, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementGroup-2","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup(measurements::Array{Int,3},\n                 basis_transformation::Array{ComplexF64,4},\n                 site_indices::Union{Vector{Index{Int64}}, Nothing}=nothing)\n\nConstruct a MeasurementGroup from raw measurement outcomes and local unitary basis transformations.\n\nArguments\n\nmeasurements::Array{Int,3}: A 3‑dimensional array of measurement outcomes with dimensions (NU, NM, N) where:\nNU = number of measurement runs,\nNM = number of measurement samples per run,\nN  = number of qubits/sites.\nbasis_transformation::Array{ComplexF64,4}: A 4‑dimensional array of local unitary transformations with dimensions (NU, N, d, d) where each slice basis_transformation[r,:,:,:] defines the measurement basis for run r.\nsite_indices::Union{Vector{Index{Int64}}, Nothing}: Optional vector of site indices. If nothing, defaults to siteinds(\"Qubit\", N).\n\nBehavior\n\nAsserts that the number of runs (NU) and sites (N) match between measurements and basis_transformation.\nFor each run r, constructs a LocalUnitaryMeasurementSetting using the corresponding basis transformation and site indices.\nWraps the raw measurement outcomes into a MeasurementData object tagged with its measurement setting.\nReturns a MeasurementGroup containing all runs.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.MeasurementGroup-Tuple{Union{MPO, MPS}, Int64, Int64}","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup(ψ::Union{MPO, MPS}, NU::Int, NM::Int; setting_type::Type=LocalUnitaryMeasurementSetting, depth::Union{Int, Nothing}=nothing, mode::SimulationMode=TensorNetwork, progress_bar::Bool=false)\n\nConstruct a MeasurementGroup from a quantum state ψ by generating NU measurement settings and simulating NM projective measurements per setting.\n\nArguments\n\nψ::Union{MPO, MPS}: The quantum state.\nNU::Int: Number of measurement data objects to generate.\nNM::Int: Number of measurements per setting.\nsetting_type::Type{<:AbstractMeasurementSetting} (optional): Type of measurement setting to use. Options:\nLocalUnitaryMeasurementSetting (default): Random local unitaries\nShallowUnitaryMeasurementSetting: Shallow quantum circuits\nComputationalBasisMeasurementSetting: Computational basis measurements\ndepth::Union{Int, Nothing} (optional): Circuit depth for shallow settings. Required when setting_type=ShallowUnitaryMeasurementSetting.\nmode::SimulationMode (optional): Simulation mode. Default is TensorNetwork.\nprogress_bar::Bool (optional): Whether to show a progress bar. Default is false.\n\nReturns\n\nA MeasurementGroup{T} object where T is the specified setting_type.\n\nExample\n\n# Local unitary measurements (default)\ngroup1 = MeasurementGroup(ψ, 10, 100)\n\n# Shallow unitary measurements\ngroup2 = MeasurementGroup(ψ, 10, 100; setting_type=ShallowUnitaryMeasurementSetting, depth=3)\n\n# Computational basis measurements\ngroup3 = MeasurementGroup(ψ, 10, 100; setting_type=ComputationalBasisMeasurementSetting)\n\nThrows\n\nArgumentError: If depth is required but not provided for ShallowUnitaryMeasurementSetting.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementGroup-Union{Tuple{Array{MeasurementData{T}, 1}}, Tuple{T}} where T<:Union{Nothing, RandomMeas.AbstractMeasurementSetting}","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup(measurements::Vector{MeasurementData{T}}) where {T <: Union{Nothing, AbstractMeasurementSetting}}\n\nConstruct a MeasurementGroup object by inferring dimensions from a vector of MeasurementData objects.\n\nArguments\n\nmeasurements::Vector{MeasurementData{T}}: A vector of MeasurementData objects.\n\nReturns\n\nA MeasurementGroup object with:\n\nN: Inferred from the first element (assumed consistent across all elements).\nNU: Number of measurement data objects.\nNM: Inferred from the first element.\nmeasurements: The provided vector.\n\nExample\n\nsetting1 = LocalUnitaryMeasurementSetting(4, ensemble=Haar)\nresults1 = rand(1:2, 10, 4)\ndata1 = MeasurementData(results1; measurement_setting=setting1)\nsetting2 = LocalUnitaryMeasurementSetting(4, ensemble=Haar)\nresults2 = rand(1:2, 10, 4)\ndata2 = MeasurementData(results2; measurement_setting=setting2)\ngroup = MeasurementGroup([data1, data2])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.MeasurementGroup-Union{Tuple{T}, Tuple{Union{MPO, MPS}, Vector{T}, Int64}} where T<:RandomMeas.AbstractMeasurementSetting","page":"Home","title":"RandomMeas.MeasurementGroup","text":"MeasurementGroup(ψ::Union{MPO, MPS}, measurement_settings::Vector{AbstractMeasurementSetting}, NM::Int; mode::String = “MPS/MPO”, progress_bar::Bool=false)\n::MeasurementGroup{T} where T <: AbstractMeasurementSetting\n\nConstruct a MeasurementGroup from a quantum state ψ by generating NU local measurement settings and simulating NM projective measurements per setting.\n\nArguments\n\nψ::Union{MPO, MPS}: The quantum state.\nmeasurement_settings::Vector{AbstractMeasurementSetting}: A vector with measurement settings\nNM::Int: Number of measurements per setting.\nmode::String: Simulation mode; defaults to “MPS/MPO”.\nprogress_bar::Bool: Whether to show a progress bar.\n\nReturns\n\nA MeasurementGroup{T} object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.export_MeasurementGroup-Union{Tuple{T}, Tuple{MeasurementGroup{T}, String}} where T<:Union{Nothing, ComputationalBasisMeasurementSetting, LocalUnitaryMeasurementSetting}","page":"Home","title":"RandomMeas.export_MeasurementGroup","text":"export_MeasurementGroup(group::MeasurementGroup{T}, filepath::String)\n\nExport a MeasurementGroup object to an NPZ file.\n\nArguments\n\ngroup::MeasurementGroup{T}: A MeasurementGroup object where each MeasurementData may have its own measurement setting of type T (with T <: Union{Nothing, LocalUnitaryMeasurementSetting, ComputationalBasisMeasurementSetting}).\nfilepath::String: The file path where the NPZ file will be written.\n\nDetails\n\nThe measurement results from each MeasurementData object (each of shape (NM, N)) are stacked into a 3D array of shape (NU, NM, N), where NU is the number of MeasurementData objects.\nThe measurement settings are exported as a Complex array of size NU x N x 2 x 2 if present.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.import_MeasurementGroup-Tuple{String}","page":"Home","title":"RandomMeas.import_MeasurementGroup","text":"import_MeasurementGroup(filepath::String; predefined_settings=nothing, site_indices=nothing) -> MeasurementGroup\n\nImport a MeasurementGroup object from an NPZ file.\n\nArguments\n\nfilepath::String: The path to the NPZ file containing the exported MeasurementGroup data.\npredefined_settings (optional): A vector of predefined measurement settings (one per MeasurementData object). If provided, its length must equal the exported NU.\nsite_indices (optional): A vector of N site indices to use when reconstructing the measurement setting. If not provided, default site indices are generated using siteinds(\"Qubit\", N).\n\nReturns\n\nA MeasurementGroup object with:\n\nMeasurement results reconstructed from a 3D array of shape (NU, NM, N).\nA measurement setting for each MeasurementData object reconstructed from a 4D array of shape (NU, N, 2, 2) if present, or taken from predefined_settings if provided.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.reduce_to_subsystem-Union{Tuple{T}, Tuple{MeasurementGroup{T}, Vector{Int64}}} where T<:Union{Nothing, LocalMeasurementSetting}","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(\ngroup::MeasurementGroup{T},\nsubsystem::Vector{Int}\n\n)::MeasurementGroup{T} where T <: LocalMeasurementSetting\n\nReduce a MeasurementGroup object (withLocalUnitaryMeasurementSetting`) to a specified subsystem.\n\nArguments\n\ngroup::MeasurementGroup{LocalUnitaryMeasurementSetting}: The original measurement data object.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns\n\nA new MeasurementGroup object corresponding to the specified subsystem.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_XEB-Tuple{MPS, MeasurementData}","page":"Home","title":"RandomMeas.get_XEB","text":"get_XEB(ψ::MPS, measurement_data::MeasurementData)\n\nReturn the linear cross-entropy for the measurement results in measurement_data, with respect to a theory state ψ.\n\nArguments\n\nψ::MPS: The theoretical state to compare against.\nmeasurement_data::MeasurementData: The measurement data object containing results and settings.\n\nReturns\n\nThe linear cross-entropy as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_calibration_vector-Tuple{MPS, MeasurementGroup}","page":"Home","title":"RandomMeas.get_calibration_vector","text":"get_calibration_vector(ψ0::MPS, measurement_group::MeasurementGroup)\n\nReturn a calibration vector G for evaluating process shadows based on the calibration initial state ψ0=0000 Reference Vitale et al, PRXQ 2025\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_fidelity","page":"Home","title":"RandomMeas.get_fidelity","text":"get_fidelity(\n    group_1::MeasurementGroup,\n    group_2::MeasurementGroup,\n    subsystem::Vector{Int} = collect(1:group_1.N)\n)\n\nCompute the fidelity of two quantum states Tr(ρ1 ρ2)/sqrt(Tr(ρ1^2) * Tr(ρ2^2)) from measurement data by averaging the overlap of measurement results.\n\nArguments\n\ngroup_1::MeasurementGroup: Measurement data for the first state.\ngroup_2::MeasurementGroup: Measurement data for the second state.\nsubsystem::Vector{Int} (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.\n\nReturns\n\nThe computed fidelity.\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.get_h_tensor","page":"Home","title":"RandomMeas.get_h_tensor","text":"get_h_tensor(s::Index, s_prime::Index, G::Float64 = 1.0) -> ITensor\n\nConstruct the Hamming tensor for given indices.\n\nArguments\n\ns::Index: Unprimed site index.\ns_prime::Index: Primed site index.\nG::Float64 (optional): G value for error correction and robustness. Defaults to 1.0.\n\nReturns\n\nHamming_tensor::ITensor: The Hamming tensor connecting s and s_prime.\n\nMethod\n\nInitializes an ITensor with indices s and s_prime.\nAssigns values to represent the Hamming distance operation:\nDiagonal elements are set to 1.0.\nOff-diagonal elements are set to -0.5.\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.get_overlap","page":"Home","title":"RandomMeas.get_overlap","text":"get_overlap(\n    group_1::MeasurementGroup,\n    group_2::MeasurementGroup,\n    subsystem::Vector{Int} = collect(1:group_1.N);\n    apply_bias_correction::Bool = false\n)\n\nCompute the overlap of two quantum states from measurement data by averaging the overlap of measurement results.\n\nArguments\n\ngroup_1::MeasurementGroup: Measurement data for the first state.\ngroup_2::MeasurementGroup: Measurement data for the second state.\nsubsystem::Vector{Int} (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.\napply_bias_correction::Bool (optional): Whether to apply bias correction for the overlap. Defaults to false.\n\nReturns\n\nThe computed overlap (or purity if group_1 == group_2 and bias correction is applied).\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.get_overlap-Tuple{MeasurementData, MeasurementData}","page":"Home","title":"RandomMeas.get_overlap","text":"get_overlap(\n    data_1::MeasurementData,\n    data_2::MeasurementData;\n    apply_bias_correction::Bool = false\n)\n\nCompute the overlap between two quantum states for a single measurement setting.\n\nArguments\n\ndata_1::MeasurementData: Measurement Data for the first state, with dimensions (NM, N).\ndata_2::MeasurementData: Measurement Data for the second state, with dimensions (NM, N).\napply_bias_correction::Bool (optional): Whether to apply bias correction for the overlap. Defaults to false.\n\nReturns\n\nThe computed overlap for the single measurement setting.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_overlap-Tuple{MeasurementProbability, MeasurementProbability}","page":"Home","title":"RandomMeas.get_overlap","text":"get_overlap(prob1::MeasurementProbability, prob2::MeasurementProbability) -> Float64\n\nCompute the weighted overlap  2^N sum_s (-2)^{-D[s,s']}P(s)P(s') by sequentially applying the Hamming tensor to each qubit index and contracting with the second probability tensor.\n\nArguments\n\nprob1::MeasurementProbability: The first Born probability tensor representing quantum state rho1.\nprob2::MeasurementProbability: The second Born probability tensor representing quantum state rho2.\n\nReturns\n\nweighted_overlap::Float64: The computed trace Tr(rho1 rho2) scaled appropriately.\n\nExample\n\nusing ITensors\n\n# Assume prob1 and prob2 are predefined MeasurementProbabilities\noverlap = get_overlap(prob1, prob2)\nprintln(\"Overlap: \", overlap)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_purity","page":"Home","title":"RandomMeas.get_purity","text":"get_purity(group::MeasurementGroup, subsystem::Vector{Int} = collect(1:group.N))\n\nCompute the purity of a quantum state from measurement data by averaging the overlap of measurement results.\n\nArguments\n\ngroup::MeasurementGroup: Measurement data containing the results and settings of randomized measurements.\nsubsystem::Vector{Int} (optional): A vector of site indices specifying the subsystem to retain. Defaults to the full system.\n\nReturns\n\nThe computed purity for the specified subsystem.\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.AbstractShadow","page":"Home","title":"RandomMeas.AbstractShadow","text":"AbstractShadow - Abstract Classical Shadow Type\n\nAn abstract type representing a general classical shadow. Concrete subtypes should implement specific shadow methodologies, such as factorized or dense shadows.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.DenseShadow","page":"Home","title":"RandomMeas.DenseShadow","text":"DenseShadow - Dense Classical Shadow\n\nA struct representing a dense classical shadow (a 2^N x 2^N matrix), stored as a single ITensor with 2N indices.\n\nFields\n\nshadow_data::ITensor: An ITensor with 2N indices representing the dense shadow.\nN::Int: Number of sites (qubits).\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nConstructor\n\nDenseShadow(shadow_data::ITensor, N::Int, site_indices::Vector{Index{Int64}}) validates that:\n\nsite_indices has length N.\nshadow_data has exactly 2N indices.\nThe set of unprimed indices in shadow_data matches site_indices.\nThe set of primed indices in shadow_data matches map(prime, site_indices).\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.FactorizedShadow","page":"Home","title":"RandomMeas.FactorizedShadow","text":"FactorizedShadow - Factorized Classical Shadow\n\nA struct representing a factorized classical shadow which can be represented as a tensor product of single qubit shadows.\n\nFields\n\nshadow_data::Vector{ITensor}: A vector of ITensors (each 2×2) representing the shadow for each qubit/site.\nN::Int: Number of qubits/sites.\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nConstructor\n\nFactorizedShadow(shadow_data::Vector{ITensor}, N::Int, site_indices::Vector{Index{Int64}}) validates that:\n\nThe length of shadow_data and site_indices equals N.\nEach ITensor in shadow_data has exactly two indices, which include the corresponding unprimed and primed site index.\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.ShallowShadow","page":"Home","title":"RandomMeas.ShallowShadow","text":"ShallowShadow - Shallow Classical Shadow\n\nA struct representing a shallow classical shadow, stored as a MPO ITensor object.\n\nFields\n\nshadow_data::MPO: An MPO representing the shallow shadow.\nN::Int: Number of sites (qubits).\nsite_indices::Vector{Index{Int64}}: A vector of site indices (length N).\n\nConstructor\n\nShallowShadow(shadow_data::MPO, N::Int, site_indices::Vector{Index{Int64}}) validates that:\n\nsite_indices has length N.\nshadow_data has exactly N Tensors, and the site indices match with site_indices\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, AbstractArray{<:AbstractShadow}}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadows::AbstractArray{<:AbstractShadow}; compute_sem::Bool = false)\n\nCompute the average expectation value of an MPO operator O using an array of shadow objects.\n\nThis function estimates the expectation value ⟨O⟩ = Tr[O·ρ] of a matrix product operator (MPO) O with respect to the quantum state ρ represented by classical shadows. Classical shadows provide an efficient way to estimate expectation values of observables from randomized measurements, enabling scalable quantum state characterization.\n\nArguments\n\nO::MPO: The matrix product operator whose expectation value is to be computed. MPOs are efficient representations of many-body observables in quantum systems.\nshadows::AbstractArray{<:AbstractShadow}: An array of shadow objects (of any shape) over which the expectation values are computed. Each shadow represents a classical snapshot of the quantum state.\ncompute_sem::Bool (optional): If true, also compute the standard error of the mean (SEM) for statistical error analysis. Default is false.\n\nReturns\n\nIf compute_sem is false, returns the average expectation value.\nIf compute_sem is true, returns a tuple (mean, sem), where mean is the average expectation value and sem is the standard error.\n\nExample\n\nmean_val = get_expect_shadow(O, shadows)\nmean_val, sem_val = get_expect_shadow(O, shadows; compute_sem=true)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, AbstractShadow}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadow::AbstractShadow)\n\nCompute the expectation value of an MPO operator O using a single shadow object.\n\nArguments\n\nO::MPO: The MPO operator for which the expectation value is computed.\nshadow::AbstractShadow: A shadow object, either dense, factorized, or shallow.\n\nReturns\n\nThe expectation value as a scalar.\n\nExample\n\nval = get_expect_shadow(O, shadow)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moment-Tuple{Matrix{<:AbstractShadow}, Int64}","page":"Home","title":"RandomMeas.get_trace_moment","text":"get_trace_moment(shadows::Array{<:AbstractShadow, 2}, kth_moment::Int; O::Union{Nothing, MPO}=nothing, compute_sem::Bool = false, compute_renyi::Bool = false)\n\nCompute a single trace moment from an array of AbstractShadow objects.\n\nThis function estimates the k-th trace moment T_k = Tr[ρ^k], or Tr[O·ρ^k] if an observable O is provided,  from classical shadow data. Trace moments are fundamental quantities in quantum state characterization and are used to compute various entanglement measures and state properties.\n\nArguments\n\nshadows::Array{<:AbstractShadow, 2}: An array of shadow objects with dimensions (n_ru, n_m), where n_ru is the number of random unitaries and n_m is the number of measurements.\nkth_moment::Int: The moment k to compute (e.g., k = 1, 2, ...).\nO::Union{Nothing, MPO} (optional): If provided, computes Tr[O * ρ^k]; otherwise, computes p_k=Tr[ρ^k] (default: nothing).\ncompute_sem::Bool (optional): If true, also computes the standard error of the mean (SEM) and bias correction using jackknife resampling (default: false).\ncompute_renyi::Bool (optional): If true, returns the Rényi-k entropy Sk = (1/(1-k)) * log₂(pk) instead of the raw trace moment (default: false).\n\nReturns\n\nIf compute_sem is false: The computed trace moment (or Rényi entropy) as a scalar.\nIf compute_sem is true: A tuple (estimate, bias, sem) where:\nestimate: The point estimate of the trace moment\nbias: The bias correction from jackknife resampling\nsem: The standard error of the mean\n\nExample\n\nmoment1 = get_trace_moment(shadows, 1)\nmoment2 = get_trace_moment(shadows, 2; O=my_operator)\nestimate, bias, sem = get_trace_moment(shadows, 2; compute_sem=true)\nrenyi_entropy = get_trace_moment(shadows, 2; compute_renyi=true)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moment-Tuple{Vector{<:AbstractShadow}, Int64}","page":"Home","title":"RandomMeas.get_trace_moment","text":"get_trace_moment(shadows::Vector{<:AbstractShadow}, kth_moment::Int; O::Union{Nothing, MPO}=nothing, compute_sem::Bool=false, compute_renyi::Bool=false)\n\nWrapper function. Compute a single trace moment for a vector of shadow objects by reshaping the vector into a 2D array.\n\nThis is a convenience function that reshapes a vector of shadow objects into a 2D array and then calls the main get_trace_moment function. It's useful when you have a flat collection of shadows but need to compute trace moments using the full statistical machinery.\n\nArguments\n\nshadows::Vector{<:AbstractShadow}: A vector of shadow objects.\nkth_moment::Int: The moment order k to compute (e.g., k = 1, 2, ...).\nO::Union{Nothing, MPO} (optional): An MPO observable. If provided, computes Tr[O * ρ^k]; otherwise, computes Tr[ρ^k] (default: nothing).\ncompute_sem::Bool (optional): If true, also computes the standard error of the mean (SEM) and bias correction using jackknife resampling (default: false).\ncompute_renyi::Bool (optional): If true, returns the Rényi-k entropy Sk = (1/(1-k)) * log₂(Tk) instead of the raw trace moment (default: false).\n\nReturns\n\nIf compute_sem is false: The computed trace moment (or Rényi entropy) as a scalar.\nIf compute_sem is true: A tuple (estimate, bias, sem) where:\nestimate: The point estimate of the trace moment\nbias: The bias correction from jackknife resampling\nsem: The standard error of the mean\n\nExample\n\nmoment = get_trace_moment(shadows_vector, 2; O=my_operator)\nestimate, bias, sem = get_trace_moment(shadows_vector, 2; compute_sem=true)\nrenyi_entropy = get_trace_moment(shadows_vector, 2; compute_renyi=true)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moments-Tuple{Matrix{<:AbstractShadow}, Vector{Int64}}","page":"Home","title":"RandomMeas.get_trace_moments","text":"get_trace_moments(\n    shadows::Array{<:AbstractShadow,2},\n    k_vec::Vector{Int};\n    O::Union{Nothing,MPO}=nothing,\n    compute_cov::Bool = false,\n    compute_renyi::Bool = false,\n)\n\nEstimate several trace moments from classical shadow data.\n\nThis function computes multiple trace moments of the form:\n\n[ p_k = \\operatorname{tr}\\bigl[\\,\\rho^{\\,k}\\bigr] ]\n\n(or, if O is supplied, the generalized moments ( \\operatorname{tr}[\\,O\\,\\rho^{\\,k}] )) from an array of classical–shadow objects.\n\nTrace moments are fundamental quantities in quantum state characterization that capture higher-order correlations and entanglement properties. They are used to compute various entanglement measures, state fidelities, and other quantum information quantities.\n\nIf compute_renyi=true for each (k) is converted on the fly to the (binary-log) Rényi-(k) entropy (S_k) is estimated:\n\n[ Sk \\,=\\, \\frac{1}{1-k}\\,\\log{2} p_k . ]\n\nOptionally compute_cov=true returns, in addition to the vector of point estimates, the full jack-knife covariance matrix ( \\operatorname{Cov}(T{ka},T{kb}) ) (or of the Rényi entropies, depending on compute_renyi).\n\nArguments\n\nshadows : 2-D array of size (n_ru, n_m) holding the classical shadows.\nn_ru: number of random unitaries\nn_m: number of measurements per unitary\nk_vec   : vector of positive integers specifying which moments to compute.\nO       : optional MPO observable; if given, moments of ( O\\,\\rho^{k} ) are computed.\ncompute_cov : whether to return the jack-knife covariance matrix for error analysis.\ncompute_renyi    : return Rényi entropies instead of raw trace moments.\n\nReturns\n\nIf compute_cov=false: θ̂::Vector{Float64} - point estimates for each k_vec[i]\nIf compute_cov=true: A tuple (θ̂, bias, Σ̂) where:\nθ̂::Vector{Float64}: point estimates for each k_vec[i]\nbias::Vector{Float64}: bias corrections from jackknife resampling\nΣ̂::Matrix{Float64}: jack-knife covariance matrix\n\nExample\n\n# Compute first three trace moments\nmoments = get_trace_moments(shadows, [1, 2, 3])\n\n# Compute with covariance matrix for error analysis\nmoments, bias, cov = get_trace_moments(shadows, [1, 2, 3]; compute_cov=true)\n\n# Compute Rényi entropies\nrenyi_entropies = get_trace_moments(shadows, [1, 2, 3]; compute_renyi=true)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moments-Tuple{Vector{<:AbstractShadow}, Vector{Int64}}","page":"Home","title":"RandomMeas.get_trace_moments","text":"get_trace_moments(shadows::Vector{<:AbstractShadow}, kth_moments::Vector{Int}; O::Union{Nothing, MPO}=nothing, compute_cov::Bool=false, compute_renyi::Bool=false)\n\nWrapper function. Compute multiple trace moments from a vector of shadow objects by reshaping the vector into a 2D array.\n\nThis is a convenience function that reshapes a vector of shadow objects into a 2D array and then calls the main get_trace_moments function. It's useful when you have a flat collection of shadows but need to compute multiple trace moments using the full statistical machinery.\n\nArguments\n\nshadows::Vector{<:AbstractShadow}: A vector of shadow objects.\nkth_moments::Vector{Int}: A vector of moment orders to compute (e.g., [1, 2, 3]).\nO::Union{Nothing, MPO} (optional): An MPO observable. If provided, computes Tr[O * ρ^k]; otherwise, computes Tr[ρ^k] (default: nothing).\ncompute_cov::Bool (optional): Whether to return the jack-knife covariance matrix for error analysis (default: false).\ncompute_renyi::Bool (optional): Return Rényi entropies instead of raw trace moments (default: false).\n\nReturns\n\nIf compute_cov=false: θ̂::Vector{Float64} - point estimates for each moment in kth_moments\nIf compute_cov=true: A tuple (θ̂, bias, Σ̂) where:\nθ̂::Vector{Float64}: point estimates for each moment in kth_moments\nbias::Vector{Float64}: bias corrections from jackknife resampling\nΣ̂::Matrix{Float64}: jack-knife covariance matrix\n\nExample\n\nmoments = get_trace_moments(shadows_vector, [1, 2, 3])\nmoments, bias, cov = get_trace_moments(shadows_vector, [1, 2, 3]; compute_cov=true)\nrenyi_entropies = get_trace_moments(shadows_vector, [1, 2, 3]; compute_renyi=true)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_product-Tuple{Vararg{AbstractShadow}}","page":"Home","title":"RandomMeas.get_trace_product","text":"get_trace_product(shadows::AbstractShadow...; O::Union{Nothing, MPO}=nothing)\n\nCompute the product of multiple shadow objects and return its trace or expectation value.\n\nThis function computes trace of products of classical shadows.\n\nIf O is nothing, returns the trace of the product:     trace(shadow₁ * shadow₂ * ... * shadowₙ). If O is provided, returns the expectation value computed by:     getexpectshadow(O, shadow₁ * shadow₂ * ... * shadowₙ).\n\nArguments\n\nshadows...: A variable number of shadow objects. The product is computed in the order provided.\nO::Union{Nothing, MPO} (optional): An MPO observable. If provided, computes the expectation value of O with respect to the product of shadows.\n\nReturns\n\nThe trace of the product if O is nothing, or the expectation value if O is provided.\n\nExample\n\nresult = get_trace_product(shadow1, shadow2, shadow3)\nresult_with_O = get_trace_product(shadow1, shadow2, shadow3; O=my_operator)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.multiply-Tuple{AbstractShadow, AbstractShadow}","page":"Home","title":"RandomMeas.multiply","text":"multiply(shadow1::AbstractShadow, shadow2::AbstractShadow)\n\nMultiply two shadow objects of the same concrete type.\n\nArguments\n\nshadow1::AbstractShadow: The first shadow object.\nshadow2::AbstractShadow: The second shadow object.\n\nReturns\n\nA new shadow object representing the product.\n\nThrows\n\nAn ArgumentError if the types of shadow1 and shadow2 do not match.\n\nExample\n\nprod_shadow = multiply(shadow1, shadow2)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_trace-Tuple{AbstractArray{<:AbstractShadow}, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_trace","text":"partial_trace(shadows::AbstractArray{<:AbstractShadow}, subsystem::Vector{Int}; assume_unit_trace::Bool=false)\n\nCompute the partial trace for each shadow in a collection of shadows.\n\nArguments\n\nshadows::AbstractArray{<:AbstractShadow}: A collection of shadow objects (vector or 2D array).\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\nassume_unit_trace::Bool (optional): If true, assumes the shadow has unit trace (default: false).   This can speed up the calculation for factorized shadows (as the trace of \"traced out\" qubits is not computed).\n\nReturns\n\nAn array of shadows reduced to the specified subsystem, with the same dimensions as the input array.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_trace-Tuple{AbstractShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_trace","text":"partial_trace(shadow::AbstractShadow, subsystem::Vector{Int}; assume_unit_trace::Bool=false)\n\nCompute the partial trace of a shadow object over the complement of the specified subsystem.\n\nThe partial trace operation is fundamental in quantum information theory for studying entanglement and reduced density matrices. It allows you to focus on a specific subsystem of a larger quantum system by \"tracing out\" the degrees of freedom of the complementary subsystem.\n\nArguments\n\nshadow::AbstractShadow: The shadow object representing the full quantum state.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain. The complement of this subsystem will be traced out.\nassume_unit_trace::Bool (optional): If true, assumes the shadow has unit trace (default: false).   This can speed up the calculation for factorized shadows (as the trace of \"traced out\" qubits is not computed).\n\nReturns\n\nA new shadow object reduced to the specified subsystem, representing the reduced density matrix of the subsystem.\n\nExample\n\nreduced_shadow = partial_trace(shadow, [1, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_transpose-Tuple{AbstractArray{<:AbstractShadow}, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(shadows::AbstractArray{<:AbstractShadow}, subsystem::Vector{Int})\n\nCompute the partial transpose for each shadow in a collection.\n\nArguments\n\nshadows::AbstractArray{<:AbstractShadow}: A collection (vector or 2D array) of shadow objects.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem(s) over which the transpose is to be performed.\n\nReturns\n\nAn array of shadow objects with the partial transpose applied, preserving the input dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_transpose-Tuple{AbstractShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(shadow::AbstractShadow, subsystem::Vector{Int})\n\nCompute the partial transpose of a shadow object over the specified subsystem(s).\n\nThe partial transpose is a crucial operation in quantum information theory, particularly for entanglement detection. The Peres-Horodecki criterion states that if a bipartite quantum state is separable, then its partial transpose must be positive semidefinite. This operation is essential for computing entanglement measures like negativity and for studying quantum correlations.\n\nThis operation is analogous to QuTiP's partial transpose method.\n\nArguments\n\nshadow::AbstractShadow: The shadow object for which the partial transpose is computed.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem(s) over which to perform the transpose.\n\nReturns\n\nA new shadow object that is the partial transpose of the input.\n\nExample\n\ntransposed_shadow = partial_transpose(shadow, [2, 4])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.trace-Tuple{AbstractArray{<:AbstractShadow}}","page":"Home","title":"RandomMeas.trace","text":"trace(shadows::AbstractArray{<:AbstractShadow})\n\nCompute the trace for each shadow in a collection of shadow objects.\n\nArguments\n\nshadows::AbstractArray{<:AbstractShadow}: A collection (vector, matrix, etc.) of shadow objects.\n\nReturns\n\nAn array of scalar trace values corresponding to each shadow, with the same dimensions as the input.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.trace-Tuple{AbstractShadow}","page":"Home","title":"RandomMeas.trace","text":"trace(shadow::AbstractShadow)\n\nCompute the trace of a shadow object.\n\nArguments\n\nshadow::AbstractShadow: A shadow object.\n\nReturns\n\nThe trace of the shadow object as a scalar.\n\nExample\n\nt = trace(shadow)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.FactorizedShadow-Tuple{Vector{Int64}, Vector{ITensor}}","page":"Home","title":"RandomMeas.FactorizedShadow","text":"FactorizedShadow(measurement_results::Vector{Int}, basis_transformation::Vector{ITensor};\n                 G::Vector{Float64} = fill(1.0, length(basis_transformation)))\n\nConstruct a FactorizedShadow object from raw measurement results and unitary transformations.\n\nArguments\n\nmeasurement_results::Vector{Int}: Vector of binary measurement results for each qubit/site.\nbasis_transformation::Vector{ITensor}: Vector of local unitary transformations applied during the measurement.\nG::Vector{Float64} (optional): Vector of G values for measurement error mitigation (default: 1.0 for all sites).\n\nReturns\n\nA FactorizedShadow object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.convert_to_dense_shadow-Tuple{FactorizedShadow}","page":"Home","title":"RandomMeas.convert_to_dense_shadow","text":"convert_to_dense_shadow(factorized_shadow::FactorizedShadow)\n\nConvert a FactorizedShadow object into a DenseShadow object.\n\nArguments\n\nfactorized_shadow::FactorizedShadow: The FactorizedShadow object to convert.\n\nReturns\n\nA DenseShadow object with the combined ITensor.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, FactorizedShadow}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadow::FactorizedShadow)\n\nCompute the expectation value of an MPO operator O using a factorized shadow.\n\nArguments\n\nO::MPO: The MPO operator for which the expectation value is computed.\nshadow::FactorizedShadow: A factorized shadow object.\n\nReturns\n\nThe expectation value as a ComplexF64 (or Float64 if purely real).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_factorized_shadows-Tuple{MeasurementData{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.get_factorized_shadows","text":"get_factorized_shadows(measurement_data::MeasurementData{LocalUnitaryMeasurementSetting};\n                       G::Vector{Float64} = fill(1.0, measurement_data.N))\n\nCompute factorized shadows for all measurement results in the provided MeasurementData.\n\nArguments\n\nmeasurement_data::MeasurementData{LocalUnitaryMeasurementSetting}: Measurement data object containing measurement results and settings.\nG::Vector{Float64} (optional): Vector of G values for measurement error correction (default: 1.0 for all sites).\n\nReturns\n\nA Vector{FactorizedShadow} of length NM containing one factorized shadow for each measurement shot.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_factorized_shadows-Tuple{MeasurementGroup{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.get_factorized_shadows","text":"get_factorized_shadows(measurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting};\n                       G::Vector{Float64} = fill(1.0, measurement_group.N))\n\nCompute factorized shadows for all measurement results in the provided MeasurementGroup.\n\nArguments\n\nmeasurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting}: Measurement data object containing measurement results and settings.\nG::Vector{Float64} (optional): Vector of G values for measurement error correction (default: 1.0 for all sites).\n\nReturns\n\nAn Array{FactorizedShadow, 2} of size (NU, NM) containing factorized shadows for each random unitary and measurement shot.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.multiply-Tuple{FactorizedShadow, FactorizedShadow}","page":"Home","title":"RandomMeas.multiply","text":"multiply(shadow1::FactorizedShadow, shadow2::FactorizedShadow)\n\nMultiply two FactorizedShadow objects element-wise.\n\nArguments\n\nshadow1::FactorizedShadow: The first FactorizedShadow object.\nshadow2::FactorizedShadow: The second FactorizedShadow object.\n\nReturns\n\nA new FactorizedShadow object representing the element-wise product of the two inputs.\n\nNotes\n\nBoth shadow1 and shadow2 must have the same number of qubits/sites.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_trace-Tuple{FactorizedShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_trace","text":"partial_trace(shadow::FactorizedShadow, subsystem::Vector{Int}; assume_unit_trace::Bool = false)\n\nCompute the partial trace of a FactorizedShadow object over the complement of the specified subsystem.\n\nArguments\n\nshadow::FactorizedShadow: The factorized shadow to compute the partial trace for.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain.\nassume_unit_trace::Bool (optional): If true, assumes all traced-out tensors have unit trace and skips explicit computation (default: false).\n\nReturns\n\nA new FactorizedShadow object reduced to the specified subsystem.\n\nNotes\n\nIf assume_unit_trace is true, avoids explicit trace computation for efficiency.\nIf assume_unit_trace is false, computes the traces of all tensors outside the subsystem and multiplies their product into the remaining tensors.\nIssues a warning if the trace product deviates significantly from 1 when assume_unit_trace is false.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_transpose-Tuple{FactorizedShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(shadow::FactorizedShadow, subsystem::Vector{Int})::FactorizedShadow\n\nCompute the partial transpose of a FactorizedShadow over the specified subsystem by swapping, for each site, the unprimed and primed indices using the swapind function. This function returns views of the underlying ITensors, avoiding unnecessary data duplication.\n\nArguments\n\nshadow::FactorizedShadow: The factorized classical shadow.\nsubsystem::Vector{Int}: A vector of 1-based site indices on which to perform the partial transpose.\n\nReturns\n\nA new FactorizedShadow with the specified sites partially transposed.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.trace-Tuple{FactorizedShadow}","page":"Home","title":"RandomMeas.trace","text":"trace(shadow::FactorizedShadow)\n\nCompute the trace of a FactorizedShadow object.\n\nArguments\n\nshadow::FactorizedShadow: The FactorizedShadow object whose trace is to be computed.\n\nReturns\n\nThe trace of the shadow as a Float64 or ComplexF64.\n\nNotes\n\nThe function computes the product of the traces of individual tensors in the factorized shadow.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.DenseShadow-Tuple{MeasurementData{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.DenseShadow","text":"DenseShadow(measurement_data::MeasurementData{LocalUnitaryMeasurementSetting}; G::Vector{Float64} = fill(1.0, measurement_data.N))\n\nConstruct a DenseShadow object from a MeasurementData object.\n\nThis constructor creates a dense shadow directly from raw measurement data by first computing the measurement probabilities and then constructing the shadow.\n\nArguments\n\nmeasurement_data::MeasurementData{LocalUnitaryMeasurementSetting}: A measurement data object containing the raw measurement results and measurement settings.\nG::Vector{Float64} (optional): Vector of G values to account for measurement errors and noise. Each element corresponds to a qubit/site. Default is 1.0 for all sites (no error mitigation).\n\nReturns\n\nA DenseShadow object containing the reconstructed shadow tensor, number of qubits, and site indices.\n\nNotes\n\nThis function internally calls MeasurementProbability(measurement_data) to compute probabilities before constructing the shadow.\nThe G values can be used to account for readout errors and other measurement imperfections.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.DenseShadow-Tuple{MeasurementProbability{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.DenseShadow","text":"DenseShadow(Probability::MeasurementProbability; G::Vector{Float64} = fill(1.0, measurement_probability.N))\n\nConstruct a DenseShadow object from a precomputed measurement probability tensor.\n\nA dense shadow represents a classical snapshot of a quantum state using the full density matrix representation. This constructor builds the shadow from measurement probabilities obtained through randomized measurements or via classical simulation.\n\nArguments\n\nProbability::MeasurementProbability{LocalUnitaryMeasurementSetting}: A measurement probability object containing the probability tensor P, measurement setting with local unitaries u, and site indices ξ.\nG::Vector{Float64} (optional): Vector of G values to account for measurement errors and noise (robust shadows). Each element corresponds to a qubit/site. Default is 1.0 for all sites (no error mitigation).\n\nReturns\n\nA DenseShadow object containing the reconstructed shadow tensor, number of qubits, and site indices.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_dense_shadows-Tuple{MeasurementGroup{LocalUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.get_dense_shadows","text":"get_dense_shadows(measurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting};\n                  G::Vector{Float64} = fill(1.0, measurement_group.N),\n                  number_of_ru_batches::Int = measurement_group.NU)\n\nCompute dense shadows for the provided measurement data in batches.\n\nThis function efficiently processes large measurement datasets by dividing the random unitaries into batches and computing averaged shadows for each batch.\n\nArguments\n\nmeasurement_group::MeasurementGroup{LocalUnitaryMeasurementSetting}: A measurement group object containing multiple measurement data sets with different random unitaries and possibly multiple measurement outcomes per unitary.\nG::Vector{Float64} (optional): Vector of G values for error correction and robustness. Each element corresponds to a qubit/site. Default is 1.0 for all sites (no error correction).\nnumber_of_ru_batches::Int (optional): Number of random unitary batches to create. Default is measurement_group.NU (one batch per random unitary).\n\nReturns\n\nA Vector{DenseShadow} containing one dense batch shadow per batch.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, DenseShadow}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadow::DenseShadow)\n\nCompute the expectation value of an MPO operator O using a dense shadow.\n\nThis function estimates the expectation value ⟨O⟩ = Tr[O·ρ] of a matrix product operator (MPO) O with respect to the quantum state ρ represented by the dense shadow. The computation involves contracting the MPO with the shadow tensor over all site indices.\n\nArguments\n\nO::MPO: The matrix product operator whose expectation value is to be computed. MPOs are efficient representations of many-body observables in quantum systems.\nshadow::DenseShadow: A dense shadow object containing the reconstructed quantum state tensor.\n\nReturns\n\nThe expectation value as a ComplexF64.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.multiply-Tuple{DenseShadow, DenseShadow}","page":"Home","title":"RandomMeas.multiply","text":"multiply(shadow1::DenseShadow, shadow2::DenseShadow)\n\nCompute the product of two dense shadows.\n\nThis function computes the product of two dense shadows, which is fundamental for estimating higher-order moments and entanglement measures..\n\nArguments\n\nshadow1::DenseShadow: The first dense shadow object.\nshadow2::DenseShadow: The second dense shadow object.\n\nReturns\n\nA new DenseShadow object that represents the product of the two input shadows.\n\nNotes\n\nThe shadows must have the same site indices (ξ) and number of qubits (N).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_trace-Tuple{DenseShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_trace","text":"partial_trace(shadow::DenseShadow, subsystem::Vector{Int})\n\nCompute the partial trace of a DenseShadow object over the complement of the specified subsystem.\n\nArguments\n\nshadow::DenseShadow: The dense shadow of the full system's quantum state.\nsubsystem::Vector{Int}: A vector of site indices (1-based) specifying the subsystem to retain. The complement of this subsystem will be traced out.\n\nReturns\n\nA new DenseShadow object reduced to the specified subsystem, representing the reduced density matrix of the subsystem.\n\nNotes\n\nThe function validates that all subsystem indices are within the valid range [1, N].\nThe subsystem indices must be unique (no duplicates allowed).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.partial_transpose-Tuple{DenseShadow, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(shadow::DenseShadow, subsystem::Vector{Int})::DenseShadow\n\nCompute the partial transpose of a DenseShadow over the specified subsystem.\n\nThe implementation swaps, for each site in the subsystem, the unprimed index with its primed partner using the swapind function.\n\nArguments\n\nshadow::DenseShadow: The dense classical shadow representing the quantum state.\nsubsystem::Vector{Int}: A vector of 1-based site indices on which to perform the partial transpose.\n\nReturns\n\nA new DenseShadow with the specified sites partially transposed.\n\nNotes\n\nThe function validates that all subsystem indices are within the valid range [1, N].\nThe subsystem indices must be unique (no duplicates allowed).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.trace-Tuple{DenseShadow}","page":"Home","title":"RandomMeas.trace","text":"trace(shadow::DenseShadow)\n\nCompute the trace of a DenseShadow object.\n\nThis function computes the trace Tr[ρ] of the quantum state represented by the dense shadow.\n\nArguments\n\nshadow::DenseShadow: The DenseShadow object whose trace is to be computed.\n\nReturns\n\nThe trace of the shadow as a Float64 or ComplexF64.\n\nNotes\n\nThe function contracts the ξ and ξ' indices of the shadow's ITensor.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.ShallowShadow-Tuple{Vector{Int64}, Vector{ITensor}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.ShallowShadow","text":"ShallowShadow(measurement_results::Vector{Int}, basis_transformation::Vector{ITensor}, inverse_shallow_map::Vector{ITensor},s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nConstruct a ShallowShadow object from raw measurement results and unitary transformations.\n\nArguments\n\nmeasurement_results::Vector{Int}: Vector of binary measurement results for each qubit/site.\nbasis_transformation::Vector{ITensor}: Vector of local unitary transformations applied during the measurement.\ninverse_shallow_map::Vector{ITensor}: The inverse shallow map.\ns::Vector{Index{Int64}}: Source indices.\nξ::Vector{Index{Int64}}: Target indices.\n\nReturns\n\nA ShallowShadow object.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.apply_map-Tuple{Vector{ITensor}, MPO, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.apply_map","text":"apply_map(map::Vector{ITensor},state::MPO,s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nApply a map map((s,s')→(ξ,ξ')) on a state of indices (ξ,ξ')\n\nArguments\n\nmap::Vector{ITensor}: The map to apply.\nstate::MPO: The state to apply the map to.\ns::Vector{Index{Int64}}: Source indices.\nξ::Vector{Index{Int64}}: Target indices.\n\nReturns\n\nA new MPO representing the result of applying the map.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_depolarization_map-Tuple{MPS, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.get_depolarization_map","text":"get_depolarization_map(depolarization_mps::MPS,s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nReturns a shallow map \\mathcal{M} parametrized by a depolarizationmps c(\\nu) where the state is depolarized over partition \\A{ u} with probability c(\\nu)=1\n\nArguments\n\ndepolarization_mps::MPS: The depolarization MPS.\ns::Vector{Index{Int64}}: Source indices.\nξ::Vector{Index{Int64}}: Target indices.\n\nReturns\n\nA Vector{ITensor} representing the depolarization map.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_depolarization_map-Tuple{Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.get_depolarization_map","text":"get_depolarization_map(depolarization_mps_data::Vector{ITensor},v::Vector{Index{Int64}},s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nReturns a shallow map \\mathcal{M} parametrized by a depolarizationmps c(\\nu) where the state is depolarized over partition \\A{ u} with probability c(\\nu)=1\n\nArguments\n\ndepolarization_mps_data::Vector{ITensor}: Vector of ITensors representing the depolarization MPS data.\nv::Vector{Index{Int64}}: Virtual indices.\ns::Vector{Index{Int64}}: Source indices.\nξ::Vector{Index{Int64}}: Target indices.\n\nReturns\n\nA Vector{ITensor} representing the depolarization map.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, MeasurementData{ShallowUnitaryMeasurementSetting}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, measurement_data::MeasurementData{ShallowUnitaryMeasurementSetting}, inverse_shallow_map::Vector{ITensor},s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nCompute the expectation value of an MPO operator O from a shallow MeasurementData and inverse shallow_map\n\nReturns\n\nThe expectation value as a ComplexF64 (or Float64 if purely real).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_expect_shadow-Tuple{MPO, ShallowShadow}","page":"Home","title":"RandomMeas.get_expect_shadow","text":"get_expect_shadow(O::MPO, shadow::ShallowShadow)\n\nCompute the expectation value of an MPO operator O using a shallow shadow.\n\nArguments\n\nO::MPO: The MPO operator for which the expectation value is computed.\nshadow::ShallowShadow: A shallow shadow object.\n\nReturns\n\nThe expectation value as a ComplexF64 (or Float64 if purely real).\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_shallow_depolarization_mps-Tuple{Vector{ShallowUnitaryMeasurementSetting}}","page":"Home","title":"RandomMeas.get_shallow_depolarization_mps","text":"get_shallow_depolarization_mps(settings::Vector{ShallowUnitaryMeasurementSetting})\n\nCompute shallow depolarization MPS vectors from a collection of shallow unitary measurement settings.\n\nArguments\n\nsettings::Vector{ShallowUnitaryMeasurementSetting}: A vector of shallow unitary measurement settings.\n\nReturns\n\nA Vector{MPS} containing depolarization vectors for each setting.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_shallow_shadows-Tuple{MeasurementData{ShallowUnitaryMeasurementSetting}, Vector{ITensor}, Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Home","title":"RandomMeas.get_shallow_shadows","text":"get_shallow_shadows(measurement_data::MeasurementData{ShallowUnitaryMeasurementSetting}, inverse_shallow_map::Vector{ITensor},s::Vector{Index{Int64}},ξ::Vector{Index{Int64}})\n\nConstruct a Vector{ShallowShadow} from MeasurementData\n\nArguments\n\nmeasurement_data::MeasurementData{ShallowUnitaryMeasurementSetting}: The measurement data object.\ninverse_shallow_map::Vector{ITensor}: The inverse shallow map.\ns::Vector{Index{Int64}}: Source indices.\nξ::Vector{Index{Int64}}: Target indices.\n\nReturns\n\nA Vector{ShallowShadow} containing one shallow shadow for each measurement shot.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.apply_depo_channel-Tuple{MPO, Vector{Float64}}","page":"Home","title":"RandomMeas.apply_depo_channel","text":"apply_depo_channel(ρ::MPO, p::Vector{Float64})\n\nApply a local depolarization channel to an MPO by modifying each site tensor according to the depolarization probability.\n\nFor each site, the channel acts as:\n\nρ[i] → (1 - p[i]) * ρ[i] + (p[i] / 2) * (ρ[i] * δ(s, s') * δ(s, s'))\n\nwhere δ(s, s') is the delta tensor that contracts the site index with its primed counterpart.\n\nArguments\n\nρ::MPO: The input Matrix Product Operator representing a density matrix.\np::Vector{Float64}: A vector of depolarization probabilities, one per site.\n\nReturns\n\nAn MPO with the depolarization channel applied on each site.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.apply_depo_channel-Tuple{MPS, Vector{Float64}}","page":"Home","title":"RandomMeas.apply_depo_channel","text":"apply_depo_channel(ψ::MPS, p::Vector{Float64})\n\nApply the local depolarization channel to an MPS by converting it to an MPO density matrix (using the outer product) and then applying the depolarization channel.\n\nArguments\n\nψ::MPS: The input Matrix Product State representing a pure state.\np::Vector{Float64}: A vector of depolarization probabilities, one per site.\n\nReturns\n\nAn MPO representing the depolarized density matrix.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.random_Pauli_layer-Tuple{Vector{Index{Int64}}, Vector{Float64}}","page":"Home","title":"RandomMeas.random_Pauli_layer","text":"random_Pauli_layer(ξ::Vector{Index{Int64}}, p::Vector{Float64})\n\nConstruct a layer of random single-qubit Pauli operations to simulate local depolarization. Upon averaging, this corresponds to the local depolarization channel with strength p.\n\nThe depolarization channel can be written as:   ρ → (1 - p) * ρ + (p/4) * (I + XρX + YρY + ZρZ)\n\nThis function approximates this channel by randomly applying Pauli operations with the following probabilities:\n\nWith probability 1 - 3p_i/4: No operation is applied (the qubit remains unchanged).\nWith probability p_i/4 each: Apply the X, Y, or Z gate.\n\nHere, p_i is the depolarization probability for qubit i.\n\nArguments\n\nξ::Vector{Index{Int64}}: A vector of ITensor indices representing the qubit sites.\np::Vector{Float64}: A vector of depolarization probabilities (one per qubit).\n\nReturns\n\nA vector of ITensors representing the applied Pauli gates. If no gate is applied on a site (with probability 1 - 3p_i/4), that site is omitted from the returned circuit.\n\nExample\n\ncircuit = random_Pauli_layer(siteinds(\"Qubit\", 5), 0.05 * ones(5))\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.random_circuit-Tuple{Vector{Index{Int64}}, Int64}","page":"Home","title":"RandomMeas.random_circuit","text":"random_circuit(ξ::Vector{Index{Int64}}, depth::Int64)\n\nCreate a random circuit of the given depth. The function returns a vector of ITensors, each representing a gate in the circuit.\n\nIf depth == 0, a single-qubit random unitary is applied to each site.\nFor depth > 0, the circuit is built layer-by-layer:\nOn odd layers, random two-qubit gates are applied on sites 1-2, 3-4, etc.\nOn even layers, random two-qubit gates are applied on sites 2-3, 4-5, etc.\n\nArguments\n\nξ::Vector{Index{Int64}}: A vector of site indices for the qubits.\ndepth::Int64: The depth of the circuit (non-negative integer).\n\nReturns\n\nA vector of ITensors representing the random circuit gates.\n\nExample\n\ncircuit = random_circuit(siteinds(\"Qubit\", 10), 3)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.random_magnetic_field_layer-Tuple{Vector{Index{Int64}}, Vector{Float64}}","page":"Home","title":"RandomMeas.random_magnetic_field_layer","text":"random_magnetic_field_layer(ξ::Vector{Index{Int64}}, p::Vector{Float64})\n\nConstruct a layer of random Rz gates representing a random magnetic field along the z-axis.\n\nFor each qubit i, a random rotation Rz is applied with a rotation angle drawn uniformly from [0, 2 pi pi). This gives an average rotation angle of pi pi on each site.\n\nArguments\n\nξ::Vector{Index{Int64}}: A vector of ITensor indices corresponding to the qubit sites.\np::Vector{Float64}: A vector of parameters (one per qubit) that set the scale of the rotation angles.\n\nReturns\n\nA vector of ITensors representing the random Rz gates applied to each qubit.\n\nExample\n\ncircuit = random_magnetic_field_layer(siteinds(\"Qubit\", 5), 0.1 * ones(5))\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.flatten-Tuple{Union{MPO, MPS, Vector{ITensor}}}","page":"Home","title":"RandomMeas.flatten","text":"flatten(O::Union{MPS, MPO, Vector{ITensor}})\n\nFlatten a Matrix Product State (MPS), Matrix Product Operator (MPO), or a vector of ITensors into a single ITensor by sequentially multiplying the constituent tensors.\n\nArguments\n\nO: An MPS, MPO, or vector of ITensors to be flattened.\n\nReturns\n\nAn ITensor representing the product of the individual tensors in O.\n\nExample\n\nA = random_mps(siteinds(\"Qubit\", 5))\nflatA = flatten(A)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_Born_MPS-Tuple{MPO}","page":"Home","title":"RandomMeas.get_Born_MPS","text":"get_Born_MPS(ρ::MPO)\n\nConstruct the Born probability vector as an MPS from an MPO representation of a density matrix ρ.\n\nThis function computes the Born probability vector P(s) = ⟨s|ρ|s⟩, where |s⟩ is a basis state. It does so by contracting each tensor of the MPO ρ with appropriate delta tensors that enforce equality between the unprimed and primed indices. The result is returned as an MPS that represents the Born probabilities over the computational basis.\n\nArguments\n\nρ::MPO: A Matrix Product Operator representing the density matrix.\n\nReturns\n\nAn MPS representing the Born probability vector.\n\nExample\n\nP = get_Born_MPS(ρ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_Born_MPS-Tuple{MPS}","page":"Home","title":"RandomMeas.get_Born_MPS","text":"get_Born_MPS(ψ::MPS)\n\nConstruct the Born probability vector P(s) = |ψ(s)|² as an MPS from an MPS representation ψ.\n\nThis function computes the probability for each computational basis state by contracting each tensor of the MPS ψ with its complex conjugate, using appropriate delta tensors to enforce index equality. The resulting MPS represents the Born probability distribution of the state.\n\nArguments\n\nψ::MPS: A matrix product state representing a pure quantum state.\n\nReturns\n\nAn MPS representing the Born probability vector, where each tensor P[i] corresponds to the probability contribution at site i.\n\nExample\n\nP = get_Born_MPS(ψ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_average_mps-Tuple{Vector{MPS}, Int64, Int64}","page":"Home","title":"RandomMeas.get_average_mps","text":"get_average_mps(ψ_list::Vector{MPS}, χ::Int64, nsweeps::Int64)\n\nApproximate the average state σ from a collection of MPS using a DMRG-like algorithm.\n\nThe algorithm finds an MPS ψ (with maximum bond dimension χ) that approximates the average state σ = Average(ψ_list). To monitor convergence, it tracks a cost function defined as:\n\ncost_function = ⟨ψ|ψ⟩ - ⟨ψ|σ⟩ - ⟨σ|ψ⟩,\n\nwhich is equivalent to (||σ - ψ||² - ⟨σ|σ⟩).\n\nArguments\n\nψ_list::Vector{MPS}: A vector of MPS objects representing individual quantum states.\nχ::Int64: The desired maximum bond dimension for the averaged MPS.\nnsweeps::Int64: The number of sweeps (iterations) to perform in the DMRG-like algorithm.\n\nReturns\n\nAn MPS representing the approximate average state with bond dimension χ.\n\nExample\n\navg_state = get_average_mps(ψ_list, 20, 10)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_entanglement_spectrum-Tuple{MPS, Int64}","page":"Home","title":"RandomMeas.get_entanglement_spectrum","text":"get_entanglement_spectrum(ψ::MPS, NA::Int64)\n\nCompute the entanglement spectrum for the bipartition defined by the first NA sites of the MPS ψ.\n\nThis function first creates a copy of ψ and orthogonalizes it up to site NA. Then, it performs an SVD on the tensor at site NA:\n\nIf NA > 1, the SVD is taken with respect to the indices corresponding to the link between sites NA-1 and NA and the physical index at site NA.\nIf NA == 1, only the physical index at site NA is used.\n\nThe returned object spec contains the singular values (which are related to the Schmidt coefficients) for the bipartition.\n\nArguments\n\nψ::MPS: A matrix product state representing a pure quantum state.\nNA::Int64: The number of sites from the left that define the subsystem for which the entanglement spectrum is computed.\n\nReturns\n\nspec: An ITensor containing the singular values from the SVD at site NA.\n\nExample\n\nspectrum = get_entanglement_spectrum(ψ, 3)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_selfXEB-Tuple{MPS}","page":"Home","title":"RandomMeas.get_selfXEB","text":"get_selfXEB(ψ::MPS)\n\nCompute the self-XEB (cross-entropy benchmarking) metric for a pure state represented as an MPS.\n\nThe self-XEB is defined as:\n\nselfXEB = 2^N * ∑ₛ |ψ(s)|⁴ - 1\n\nwhere the sum is over all computational basis states s and N is the number of sites (qubits). This function first computes the Born probability MPS from ψ, then calculates the inner product of the probability MPS with itself, scales the result by 2^N, and finally subtracts 1.\n\nArguments\n\nψ::MPS: A Matrix Product State representing a pure quantum state.\n\nReturns\n\nA scalar (Float64) representing the self-XEB value.\n\nExample\n\nx = get_selfXEB(ψ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_siteinds-Tuple{Union{MPO, MPS}}","page":"Home","title":"RandomMeas.get_siteinds","text":"get_siteinds(ψ::Union{MPS, MPO})\n\nRetrieve the site indices for a quantum state represented as an MPS or MPO.\n\nArguments\n\nψ: The quantum state, which can be either a Matrix Product State (MPS) or a Matrix Product Operator (MPO).\n\nReturns\n\nA vector of site indices corresponding to the quantum state ψ.\n\nExample\n\nξ = get_siteinds(ψ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace-Tuple{MPO}","page":"Home","title":"RandomMeas.get_trace","text":"get_trace(ρ::MPO)\n\nCompute the trace of a Matrix Product Operator (MPO) ρ by contracting each tensor with a delta function that equates its unprimed and primed indices.\n\nArguments\n\nρ::MPO: A matrix product operator representing a quantum state or operator.\n\nReturns\n\nA scalar representing the trace of ρ.\n\nExample\n\nt = get_trace(ρ)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moment","page":"Home","title":"RandomMeas.get_trace_moment","text":"get_trace_moment(ψ::Union{MPS, MPO}, k::Int, subsystem::Vector{Int}=collect(1:length(ψ)))\n\nCompute the kth trace moment of the reduced density matrix for a given subsystem of a quantum state.\n\nFor a pure state (MPS) and when the subsystem is contiguous starting from site 1, the function computes the entanglement spectrum of the bipartition defined by the last site in subsystem and returns the kth moment of the squared Schmidt coefficients. Otherwise, the function reduces the state to the specified subsystem.\n\nFor k = 2 (purity), it returns the squared norm (which is equivalent to tr(ρ²)). For k > 2, it computes ρ^k via repeated application of the apply function (with a cutoff) and returns the trace of the resulting tensor.\n\nArguments\n\nψ::Union{MPS, MPO}: The quantum state, represented as an MPS (for pure states) or MPO (for mixed states).\nk::Int: The moment order to compute (must be an integer ≥ 1).\nsubsystem::Vector{Int} (optional): A vector of site indices (1-based) specifying the subsystem to retain. Defaults to all sites.\n\nReturns\n\nA scalar (Float64) representing the kth trace moment of the reduced density matrix.\n\nExample\n\nmoment = get_trace_moment(ψ, 3, [1, 2, 3]; partial_transpose=false)\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.get_trace_moment-Tuple{ITensor, Int64}","page":"Home","title":"RandomMeas.get_trace_moment","text":"get_trace_moment(spec::ITensor, k::Int)\n\nCompute the kth moment of the entanglement spectrum represented by the ITensor spec.\n\nThe function assumes that spec is a square ITensor whose diagonal elements correspond to the singular values (Schmidt coefficients) of a reduced density matrix. The kth moment is computed as:\n\npk = ∑ₗ (spec[l, l]^(2*k))\n\nwhich effectively computes the sum over the kth powers of the squared singular values.\n\nArguments\n\nspec::ITensor: A square ITensor representing the entanglement spectrum.\nk::Int: The moment order to compute (must be an integer ≥ 1).\n\nReturns\n\nA scalar (Float64) corresponding to the kth moment.\n\nExample\n\nmoment = get_trace_moment(spec, 2)\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.get_trace_moments","page":"Home","title":"RandomMeas.get_trace_moments","text":"get_trace_moments(ψ::Union{MPS, MPO}, k_vector::Vector{Int}, subsystem::Vector{Int}=collect(1:length(ψ)))\n\nCompute a vector of trace moments for a quantum state ψ over a specified subsystem.\n\nFor each moment order k in k_vector, the function computes the kth trace moment of the reduced density matrix obtained by applying reduce_to_subsystem(ψ, subsystem).\n\nArguments\n\nψ::Union{MPS, MPO}: The quantum state, represented as an MPS (for pure states) or an MPO (for mixed states).\nk_vector::Vector{Int}: A vector of integer moment orders (each ≥ 1) for which the trace moments are computed.\nsubsystem::Vector{Int} (optional): A vector of site indices (1-based) specifying the subsystem to consider. Defaults to all sites.\n\nReturns\n\nA vector of scalars, each being the kth trace moment corresponding to the entries of k_vector.\n\nExample\n\nmoments = get_trace_moments(ψ, [1, 2, 3], [1, 2, 3])\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.partial_transpose-Tuple{MPO, Vector{Int64}}","page":"Home","title":"RandomMeas.partial_transpose","text":"partial_transpose(ρ::MPO, subsystem::Vector{Int})\n\nCompute the partial transpose of an MPO over the sites specified by subsystem.\n\nFor each site index in the MPO:\n\nIf the index is in the subsystem, the tensor is transposed by swapping its unprimed and primed indices using swapind.\nOtherwise, the tensor is left unchanged (multiplied by 1.0 for type consistency).\n\nArguments\n\nρ::MPO: A Matrix Product Operator representing a density matrix.\nsubsystem::Vector{Int}: A vector of site indices (1-based) over which to apply the transpose.\n\nReturns\n\nAn MPO in which the tensors corresponding to the sites in subsystem have been partially transposed.\n\nExample\n\nρT = partial_transpose(ρ, [2, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.reduce_to_subsystem","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(ρ::MPO, subsystem::Vector{Int64}, renormalize=false)\n\nCompute the reduced density matrix (as an MPO) for a specified subsystem.\n\nArguments\n\nρ::MPO: A Matrix Product Operator representing the full density matrix.\nsubsystem::Vector{Int64}: A vector of site indices (1-based) specifying the subsystem to retain.\nrenormalize (optional): Whether to renormalize the result (default: false).\n\nReturns\n\nAn MPO representing the reduced density matrix over the sites specified in subsystem.\n\nExample\n\nρ_reduced = reduce_to_subsystem(ρ, [2, 3])\n\n\n\n\n\n","category":"function"},{"location":"#RandomMeas.reduce_to_subsystem-Tuple{MPS, Vector{Int64}}","page":"Home","title":"RandomMeas.reduce_to_subsystem","text":"reduce_to_subsystem(ψ::MPS, subsystem::Vector{Int64})\n\nCompute the reduced density matrix for a pure state represented by the MPS ψ over the specified subsystem.\n\nThis function first constructs the density matrix by taking the outer product of ψ with itself, and then applies the MPO version of reduce_to_subsystem to obtain the reduced density matrix for the sites specified in subsystem.\n\nArguments\n\nψ::MPS: A Matrix Product State representing a pure quantum state.\nsubsystem::Vector{Int64}: A vector of site indices (1-based) specifying the subsystem to retain.\n\nReturns\n\nAn MPO representing the reduced density matrix over the specified subsystem.\n\nExample\n\nρ_sub = reduce_to_subsystem(ψ, [2, 3])\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.SimulationMode","page":"Home","title":"RandomMeas.SimulationMode","text":"SimulationMode - Simulation Method Type\n\nEnum for specifying the simulation method.\n\nValues\n\nDense: Dense matrix representation\nTensorNetwork: Tensor network (MPS/MPO) representation\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas.UnitaryEnsemble","page":"Home","title":"RandomMeas.UnitaryEnsemble","text":"UnitaryEnsemble - Unitary Ensemble Type\n\nEnum for specifying the type of unitary ensemble.\n\nValues\n\nHaar: Haar-random unitaries\nPauli: Random Pauli rotations\nIdentity: Identity transformation\n\n\n\n\n\n","category":"type"},{"location":"#RandomMeas._parse_project_toml-Tuple{String}","page":"Home","title":"RandomMeas._parse_project_toml","text":"_parse_project_toml(field::String)\n\nParse a specific field from the Project.toml file.\n\nArguments\n\nfield::String: The field name to extract from Project.toml.\n\nReturns\n\nThe value of the specified field from Project.toml.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.pkg_dir-Tuple{}","page":"Home","title":"RandomMeas.pkg_dir","text":"pkg_dir()\n\nGet the package root directory path.\n\nReturns\n\nA string containing the path to the package root directory.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.src_dir-Tuple{}","page":"Home","title":"RandomMeas.src_dir","text":"src_dir()\n\nGet the source directory path of the current module.\n\nReturns\n\nA string containing the path to the source directory.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.uuid-Tuple{}","page":"Home","title":"RandomMeas.uuid","text":"uuid()\n\nGet the UUID of the package.\n\nReturns\n\nA Base.UUID representing the package UUID.\n\n\n\n\n\n","category":"method"},{"location":"#RandomMeas.version-Tuple{}","page":"Home","title":"RandomMeas.version","text":"version()\n\nGet the version number of the package.\n\nReturns\n\nA VersionNumber representing the package version.\n\n\n\n\n\n","category":"method"}]
}
